// $Header$

// FlexLexer.h -- define a base class for lexical analyzers generated by flex

// Copyright (c) 1993 The Regents of the University of California.
// All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Kent Williams.
//
// Redistribution and use in source and binary forms are permitted provided
// that: (1) source distributions retain this entire copyright notice and
// comment, and (2) distributions including binaries display the following
// acknowledgement:  ``This product includes software developed by the
// University of California, Berkeley and its contributors'' in the
// documentation or other materials provided with the distribution and in
// all advertising materials mentioning features or use of this software.
// Neither the name of the University nor the names of its contributors may
// be used to endorse or promote products derived from this software without
// specific prior written permission.
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

#ifndef __FLEXCXX_H
#define __FLEXCXX_H

#include <stdio.h>


class yyFlexLexer {
 public:
	yyFlexLexer( FILE* arg_yyin = 0, FILE* arg_yyout = 0 )
		{
		yyin = arg_yyin;
		yyout = arg_yyout;
		yy_c_buf_p = (YY_CHAR*) 0;
		yy_init = 1;
		yy_start = 0;

		yy_did_buffer_switch_on_eof = 0;

		yy_looking_for_trail_begin = 0;
		yy_more_flag = 0;
		yy_more_len = 0;

		yy_current_buffer = 0;

#ifdef YY_USES_REJECT
		yy_state_buf = new yy_state_type[YY_BUF_SIZE + 2];
#else
		yy_state_buf = 0;
#endif
		}

	virtual ~yyFlexLexer()
		{
		delete yy_state_buf;
		}

	void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer );
	YY_BUFFER_STATE yy_create_buffer( FILE* file, int size );
	void yy_delete_buffer( YY_BUFFER_STATE b );
	void yyrestart( FILE *input_file );

	virtual int yylex() = 0;

 protected:
	virtual int LexerInput( char* buf, int max_size )
		{
		return read( fileno(yyin), buf, max_size );
		}

	virtual void LexerOutput( const char* buf, int size )
		{
		(void) fwrite( (char*) buf, size, 1, yyout );
		}

	void yyunput( YY_CHAR c, YY_CHAR* buf_ptr );
	int yyinput();

	void yy_load_buffer_state();
	void yy_init_buffer( YY_BUFFER_STATE b, FILE* file );

	yy_state_type yy_get_previous_state();
	yy_state_type yy_try_NUL_trans( yy_state_type current_state );
	int yy_get_next_buffer();

	FILE* yyin;	// input source for default LexerInput
	FILE* yyout;	// output sink for default LexerOutput

	YY_BUFFER_STATE yy_current_buffer;

	// yy_hold_char holds the character lost when yytext is formed.
	YY_CHAR yy_hold_char;

	// Number of characters read into yy_ch_buf.
	int yy_n_chars;

	YY_CHAR* yytext;
	int yyleng;

	// Points to current character in buffer.
	YY_CHAR* yy_c_buf_p;

	int yy_init;		// whether we need to initialize
	int yy_start;		// start state number

	// Flag which is used to allow yywrap()'s to do buffer switches
	// instead of setting up a fresh yyin.  A bit of a hack ...
	int yy_did_buffer_switch_on_eof;

	// The following are not always needed, but may be depending
	// on use of certain flex features (like REJECT or yymore()).

	yy_state_type yy_last_accepting_state;
	YY_CHAR* yy_last_accepting_cpos;

	yy_state_type* yy_state_buf;
	yy_state_type* yy_state_ptr;

	YY_CHAR* yy_full_match;
	int* yy_full_state;
	int yy_full_lp;

	int yy_lp;
	int yy_looking_for_trail_begin;

	int yy_more_flag;
	int yy_more_len;
};
#endif
