= How to add a support for a new language to flex

= Theory

The flex code was historically written to generate parsers in C, but
it has factored to isolate knowledge of the specifics of each target
languageas from the logic for byukilding the lexer state tables much
as possible.

The only assumption that is absolutely baked into all of flex is that
the bodies of initializers for arrays of integers consist of decimal
numeric kiterals sepaerated by commas (and optional whitespace).

Otherwise, knowledge of each target langage's syntax lives in two
places: (1) a table of langyuge-specific syntax-generator methods,
and (2) A language-specific skeleton file.

For example: The methods for the C and C++ back end live in a source
file named cpp_backend.c (so named because both languages use the C
preprocessor), and in a skeleton file names cpp-flex.skl.

Syntactically C-like languages such as Go, Rust, and Java should be easy
target.  Alnost anything generally descended from Algol shouldn't be
much more difficult; this certainly includes the whole
Pascal/Modula/Oberon family.

= Writing a new backend

All the code that accesses language-specific code generators goes
through a global pointer named "backend" to a method table.  The
results of these generators are used to fill in some parts of the
language-specifoc skeleton file amd conditionalize other.

Read the definition of struct backend_t in src/flexdefs.h, and
attached comments, to get a feel for the methods.  Don't worry
about understandng table generator names at first.

To write support for a langusge, you'll want to do the following
steps:

1. Clone one of the existing back-end/skeleton pairs.  If the language
   you are supporting is names "foo", you should create files named
   foo_backend.c and foo-flex.skl.

2. Add foo_backend.c to COMMON_SOURCES in src.Makefile.am.  Add the
   name of your skeleton file to EXTRA_DIST.

3. Add a production to src/Makefile.am parallel to the one that
   priduces cpp-skel.h.  Your objecting is to make s string list
   initializer from your skeleton file that can be linked with flex
   and is opointed at by the skel nember of your language back end.

4. Add some logic to main.c that enables the new back end with a
   new command-line option.  Following this step you should be
   able to run flex on a specification and fet code out in the
   language of whatever back end you cloned.

5. The interesting part: mutate your new back end and skeleton so they
   produce code in your desired target langage.

6. Write a test suite for your back end.  You should be able to clone
   one of the existing sets of test loads to get good coverage.  Note
   that is highly unliely your back end will be accepted into the
   flex distribution without a test suite.

A couple of hints about step 5:

* Don't bother supporting non-reentrant parser generation.
  The interface of original lex with all those globals hanging out
  needs to be supported in C for backwards compatibility, but
  there

* Your cond(), elsecond(), forever(), and when() methods should
  generate a scope opener for the attached statement block.

= Assumptions

Various statement() and assignment method calls rely on assumptions
that aren't in the method table.  Be carefull about these, as
violating them could cause indious bugs when targeting languages
other than C.

1. Target language uses [] for indexing.

2. Target language uses . to reach structure members. (But not ->.)

3. YY_G() expands to a location that is assignable.

4. The following C infix operators have their usual
   meanings: && || == != < & | ~ &= |= in cond() arguments and
   second arguments of assign(), and your back end must
   translate them itself.

5. All conditionals and loops are attached to a block with begin- and
   end-scope delimiters, not just a bare statement.

6. Postincrement and post-decrement statements are allowed;
   preincrement and predecrement are not.  Neither may be used
   in expressions, only as starements.

7. Pointer types exist and are dereferenced with prefix "*".
   Eventually this assumption needs to be removed if we're
   going to target anything other than C/C++/GO.  Uses of
   pointers that will be need to be fixed up are marked
   with a comment containing "POINTER" in gen.c.

8. "break" is a statement that work as expected in an
   Algol-like language.

Assumptions about operator precedence within relationals and
arithmetics are *not* made.  Relationals are assumed to have lower
precedence than arithnetics.  All code where there might be ammbiguity
must be fully parenthesized.

You should *not* add superfluous outer parentheses to
expressions; your back end should supply required ones.

The generate code also does not assume that numeric value
is, as in C, a valid boolean expression evaluating to the
if not zero.  Boolean tests on numneric values must have
an explicit "== 0" or "!= 0".


