%# -*-C-*- vi: set ft=c:
%#
%# This is the C99 front end.  While it can be used as a production
%# skeleton for generating C tokenizers it is actually intended
%# as a porting base that can be cloned and translated into non-C
%# languages.  Accordingly it cuts use of the C preprocessor to
%# the bare minimum needed to keep it working in C.
%#
%# Note that using m4 rather than C for macro definitions means they
%# will not automatically be recognized and expended in user actions nor
%# in user code sections. Anything you need to be visible there
%# needs to be declared as a function or have a rewrite rule
%# that dequotes the macro.
%#
%# The m4 macros complicate reading this code enough that being
%# prescriptive about whitespace and braces is more than usually
%# important. So please set your C style to K&R, aka 1TBS with
%# tabs when editing this file. Braces around single-statement
%# if/while/for/do/switch/break bodies are mandatory.
%#

%#  Macros for preproc stage.
m4preproc_changecom

%# Macros for runtime processing stage.
m4_changecom
m4_changequote
m4_changequote([[, ]])

%# Properties not used in the skeleton - meant to be read by the Flex code
m4_define([[M4_PROPERTY_BACKEND_NAME]], [[C99]])
m4_define([[M4_PROPERTY_SOURCE_SUFFIX]], [[c]])
m4_define([[M4_PROPERTY_TRACE_LINE_REGEXP]], [[^#line ([0-9]+) "(.*)"]])
m4_define([[M4_PROPERTY_TRACE_LINE_TEMPLATE]], [[#line %d "%s"]])
m4_define([[M4_PROPERTY_CONTEXT_ARG]], [[yyscanner]])
m4_define([[M4_PROPERTY_CONTEXT_FORMAT]], [[yyscanner->%s_r]])
m4_define([[M4_PROPERTY_BUFFERSTACK_CONTEXT_FORMAT]], [[yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->bs_%s]])

%# Macro hooks used by Flex code generators start here
m4_define([[M4_HOOK_INT32]], [[int32_t]])
m4_define([[M4_HOOK_INT16]], [[int16_t]])
m4_define([[M4_HOOK_COMMENT_OPEN]], [[/*]])
m4_define([[M4_HOOK_COMMENT_CLOSE]], [[*/]])
%# If this is not defined, no trace lines will be generated.
m4_define([[M4_HOOK_TRACE_LINE_FORMAT]], [[#line $1 "$2"
]])
m4_define([[M4_HOOK_TABLE_OPENER]], [[{]])
m4_define([[M4_HOOK_TABLE_CONTINUE]], [[},]])
m4_define([[M4_HOOK_TABLE_CLOSER]], [[};]])
m4_define([[M4_HOOK_RELATIVIZE]], [[$1]])
m4_define([[M4_HOOK_STATE_ENTRY_FORMAT]], [[	&yy_transition[$1],
]])
m4_define([[M4_HOOK_NORMAL_STATE_CASE_ARM]], [[	case $1:]])
m4_define([[M4_HOOK_EOF_STATE_CASE_ARM]], [[	case YY_STATE_EOF($1):]])
m4_define([[M4_HOOK_EOF_STATE_CASE_FALLTHROUGH]], [[		/* FALLTHROUGH */]])
m4_define([[M4_HOOK_EOF_STATE_CASE_TERMINATE]], [[		yyterminate();
]])
m4_define([[M4_HOOK_TAKE_YYTEXT]], [[yy_do_before_action(yyscanner, yy_cp, yy_bp); /* set up yytext */]])
m4_define([[M4_HOOK_RELEASE_YYTEXT]], [[*yy_cp = yyscanner->yy_hold_char; /* undo effects of setting up yytext */]])
m4_define([[M4_HOOK_CHAR_REWIND]], [[yyscanner->yy_c_buf_p = yy_cp -= $1;]])
m4_define([[M4_HOOK_LINE_REWIND]], [[yy_lineno_rewind_to(yy_cp, yy_cp - $1, yyscanner);]])
m4_define([[M4_HOOK_CHAR_FORWARD]], [[yyscanner->yy_c_buf_p = yy_cp = yy_bp + $1;]])
m4_define([[M4_HOOK_LINE_FORWARD]], [[yy_lineno_rewind_to(yy_cp, yy_bp + $1, yyscanner);]])
m4_define([[M4_HOOK_CONST_DEFINE_BYTE]], [[const char $1 = $2;
]])
m4_define([[M4_HOOK_CONST_DEFINE_STATE]], [[#define $1 $2
]])
m4_define([[M4_HOOK_CONST_DEFINE_UINT]], [[const unsigned int $1 = $2;
]])
m4_define([[M4_HOOK_CONST_DEFINE_BOOL]], [[const bool $1 = $2;
]])
m4_define([[M4_HOOK_CONST_DEFINE_UNKNOWN]], [[m4_define($1, [[$2]])]])
m4_define([[M4_HOOK_SET_YY_DECL]], [[m4_define([[YY_DECL]], [[$1]])]])
m4_define([[M4_HOOK_SET_OFFSET_TYPE]], [[m4_define([[YY_OFFSET_TYPE]], [[$1]])]])
m4_define([[M4_HOOK_SET_USERINIT]], [[m4_define([[YY_USER_INIT]], [[$1]])]])
m4_define([[M4_HOOK_SET_RULE_SETUP]], [[m4_ifdef([[M4_MODE_BOL_NEEDED]], [[
	rule_check_bol(yyscanner);
]])	m4_ifdef([[YY_USER_ACTION]], YY_USER_ACTION)
]])
m4_define([[M4_HOOK_SET_PREACTION]], [[m4_define([[YY_USER_ACTION]], [[$1]])]])
m4_define([[M4_HOOK_STATE_CASE_BREAK]], [[/*LINTED*/break;]])
m4_define([[M4_HOOK_SET_POSTACTION]], [[m4_define([[M4_HOOK_STATE_CASE_BREAK]], [[$1]])]])
m4_define([[M4_HOOK_FATAL_ERROR]], [[yypanic($1, yyscanner);]])
m4_define([[M4_HOOK_ECHO]], [[yyecho(yyscanner);]])

m4_define([[yyterminate]], m4_ifdef([[M4_MODE_YYTERMINATE]], [[M4_MODE_YYTERMINATE /* $1 */]], [[return YY_NULL /* $1 */]]))

%# Return all but the first "n" matched characters back to the input stream.
m4_define([[yyless]], [[
	do {
		/* Undo effects of setting up yytext. */
		int yyless_macro_arg = ($1);
		m4_ifdef([[M4_MODE_YYLINENO]], [[yy_less_lineno(yyless_macro_arg, yyscanner);]])
		*yy_cp = yyscanner->yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET
		yyscanner->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ;
		yy_do_before_action(yyscanner, yy_cp, yy_bp); /* set up yytext again */
	} while ( 0 )
]])

%# Can't be a function given the context-arg treatment due to the goto.
m4_define([[M4_HOOK_REJECT]], [[{
				*yy_cp = yyscanner->yy_hold_char; /* undo effects of setting up yytext */
				yy_cp = yyscanner->yy_full_match; /* restore poss. backed-over text */
m4_ifdef( [[M4_MODE_VARIABLE_TRAILING_CONTEXT_RULES]], [[
				yyscanner->yy_lp = yyscanner->yy_full_lp; /* restore orig. accepting pos. */
				yyscanner->yy_state_ptr = yyscanner->yy_full_state; /* restore orig. state */
				yy_current_state = *yyscanner->yy_state_ptr; /* restore curr. state */
]])
				++yyscanner->yy_lp;
				goto find_rule;
}
]])

%% [0.0] Make hook macros available to Flex

const int YY_FLEX_MAJOR_VERSION = FLEX_MAJOR_VERSION;
const int YY_FLEX_MINOR_VERSION = FLEX_MINOR_VERSION;
const int YY_FLEX_SUBMINOR_VERSION = FLEX_SUBMINOR_VERSION;

%# STARTS prefix machinery
%#
%# The complexity here is necessary so that m4 preserves
%# the argument lists to each C function.
%#
%# If your target language has OO you can generate a class definition,
%# use option yyclass to pass in the class name, and drop prefix support.
%# In languages like Go with a coincept of package names the prefix option
%# should be used for setting that.

m4_ifdef( [[M4_MODE_PREFIX]],, [[m4_define([[M4_MODE_PREFIX]], [[yy]])]])

m4preproc_define(`M4_GEN_PREFIX',``
[[#ifdef yy$1
#define ]]M4_MODE_PREFIX[[$1_ALREADY_DEFINED
#else
#define yy$1 ]]M4_MODE_PREFIX[[$1
#endif]]
'')

m4_ifelse(M4_MODE_PREFIX,yy,,
    M4_GEN_PREFIX(`_create_buffer')
    M4_GEN_PREFIX(`_delete_buffer')
    M4_GEN_PREFIX(`_scan_buffer')
    M4_GEN_PREFIX(`_scan_string')
    M4_GEN_PREFIX(`_scan_bytes')
    M4_GEN_PREFIX(`_init_buffer')
    M4_GEN_PREFIX(`_flush_buffer')
    M4_GEN_PREFIX(`_load_buffer_state')
    M4_GEN_PREFIX(`_switch_to_buffer')
    M4_GEN_PREFIX(`push_buffer_state')
    M4_GEN_PREFIX(`pop_buffer_state')
    M4_GEN_PREFIX(`ensure_buffer_stack')
    M4_GEN_PREFIX(`lex')
    M4_GEN_PREFIX(`restart')
    M4_GEN_PREFIX(`lex_init')
    M4_GEN_PREFIX(`lex_init_extra')
    M4_GEN_PREFIX(`lex_destroy')
    M4_GEN_PREFIX(`get_debug')
    M4_GEN_PREFIX(`set_debug')
    M4_GEN_PREFIX(`get_extra')
    M4_GEN_PREFIX(`set_extra')
    M4_GEN_PREFIX(`get_in')
    M4_GEN_PREFIX(`set_in')
    M4_GEN_PREFIX(`get_out')
    M4_GEN_PREFIX(`set_out')
    M4_GEN_PREFIX(`get_leng')
    M4_GEN_PREFIX(`get_text')
    M4_GEN_PREFIX(`get_lineno')
    M4_GEN_PREFIX(`set_lineno')
    M4_GEN_PREFIX(`get_column')
    M4_GEN_PREFIX(`set_column')
    M4_GEN_PREFIX(`wrap')
)

m4_ifdef( [[M4_YY_BISON_LVAL]],
[[
    M4_GEN_PREFIX(`get_lval')
    M4_GEN_PREFIX(`set_lval')
]])

m4_ifdef( [[<M4_YY_BISON_LLOC>]],
[[
    M4_GEN_PREFIX(`get_lloc')
    M4_GEN_PREFIX(`set_lloc')
]])


m4_ifelse(M4_MODE_PREFIX,yy,,
    M4_GEN_PREFIX(`alloc')
    M4_GEN_PREFIX(`realloc')
    M4_GEN_PREFIX(`free')
)

%# ENDS prefix machinery

/* STARTS platform-specific and compiler-specific definitions. */

m4_ifdef( [[M4_YY_ALWAYS_INTERACTIVE]], ,
[[m4_ifdef( [[M4_YY_NEVER_INTERACTIVE]], ,
[[/* Feature test macros. Flex uses functions that require a minimum set of
 * macros defined. As defining some macros may hide function declarations that
 * user code might use, be conservative and respect user's definitions as much
 * as possible. In glibc, feature test macros may not be all set up until one
 * of the libc header (that includes <features.h>) is included. This creates
 * a circular dependency when we check the macros. <assert.h> is the safest
 * header we can include and does not declare too many functions we don't need.
 */
#if !defined(__GNU_LIBRARY__) && defined(__STDC__)
#include <assert.h>
#endif
#if !(defined(_POSIX_C_SOURCE) || defined(_XOPEN_SOURCE) || \
    defined(_POSIX_SOURCE))
# define _POSIX_C_SOURCE 1 /* Required for fileno() */
# define _POSIX_SOURCE 1
#endif]])]])

#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <unistd.h>	/* required for isatty() */

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/*
 * Anywhere other than C this won't be a thing,
 * because strings will have an associated length field.
 */
const int YY_END_OF_BUFFER_CHAR = 0;

/* ENDS platform-specific and compiler-specific definitions. */

/*
 * Amount of stuff to slurp up with each read.
 * We assume the stdio library has already
 * chosen a fit size foe whatever platform
 * we're running on.
 */
const int YY_READ_BUF_SIZE = BUFSIZ;

/* Size of default input buffer. We want to be able to fit two
 * OS-level reads, but efficiency gains as the buffer size
 * increases fall off after that
 */
const int YY_BUF_SIZE =  m4_ifdef([[M4_MODE_YY_BUFSIZE]], [[M4_MODE_YY_BUFSIZE]], [[2 * YY_READ_BUF_SIZE]]);

/* Returned upon end-of-file. */
const int YY_NULL = 0;

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
m4_define([[YY_SC_TO_UI]], [[((YY_CHAR)($1))]])

/* In the ancestral C back end this was a void pointer, meant to be
 * opaque pointer.  That indirection has been removed here as it
 * wouldn't easily port to other languages.
 */
typedef struct yyguts_t *yyscan_t;

/* Action number for EOF rule of a given start state. */
m4_define([[YY_STATE_EOF]], [[YY_END_OF_BUFFER + $1 + 1]])

/* The state buf must be large enough to hold one state per character in the main buffer,
 * plus the start state, plus the two end-of-buffer byte states.
 */
m4_define([[YY_STATE_BUF_EXTRA_SPACE]], [[3]])
m4_define([[YY_STATE_BUF_SIZE]], [[(YY_BUF_SIZE + YY_STATE_BUF_EXTRA_SPACE)]])

const bool FLEX_DEBUG = m4_ifdef([[M4_MODE_DEBUG]], [[true]], [[false]]);

typedef uint8_t YY_CHAR;

m4_ifdef( [[M4_MODE_FULLSPD]], [[m4_dnl
typedef const struct yy_trans_info *yy_state_type;
]], [[
typedef int yy_state_type;
]])

%% [1.0] DFA

struct yy_trans_info {
	/* We require that yy_verify and yy_nxt must be of the same size int. */
m4_ifdef([[M4_MODE_REAL_FULLSPD]], [[
	YY_OFFSET_TYPE yy_verify;

	/* In cases where its sister yy_verify *is* a "yes, there is
	 * a transition", yy_nxt is the offset (in records) to the
	 * next state.  In most cases where there is no transition,
	 * the value of yy_nxt is irrelevant.  If yy_nxt is the -1th
	 * record of a state, though, then yy_nxt is the action number
	 * for that state.
	 */
	 YY_OFFSET_TYPE yy_nxt;
]])
m4_ifdef([[M4_MODE_NO_REAL_FULLSPD]], [[
	/* We generate a bogus 'struct yy_trans_info' data type
	 * so we can guarantee that it is always declared in the skel.
	 * This is so we can compile "sizeof(struct yy_trans_info)"
	 * in any scanner.
	 */
	int32_t yy_verify;
	int32_t yy_nxt;
]])
};

%% [2.0] payload macros for the DFA data tables are inserted here

m4_ifdef( [[M4_HOOK_NXT_ROWS]],[[m4_dnl
static const M4_HOOK_NXT_TYPE yy_nxt[][M4_HOOK_NXT_ROWS] =
M4_HOOK_NXT_BODY
]])

m4_ifdef( [[M4_MODE_YYLINENO]],[[m4_dnl
/* Table of booleans, true if rule could match eol. */
static const M4_HOOK_EOLTABLE_TYPE yy_rule_can_match_eol[M4_HOOK_EOLTABLE_SIZE] = { 0,
M4_HOOK_EOLTABLE_BODY[[]]m4_dnl
};
]])

m4_ifdef( [[M4_HOOK_NEED_ACCEPT]],[[m4_dnl
static const M4_HOOK_ACCEPT_TYPE yy_accept[M4_HOOK_ACCEPT_SIZE] = { 0,
M4_HOOK_ACCEPT_BODY[[]]m4_dnl
};
]])

m4_ifdef( [[M4_MODE_USEECS]],[[m4_dnl
/* Character equivalence-class mapping */
static const YY_CHAR yy_ec[M4_HOOK_ECSTABLE_SIZE] = { 0,
M4_HOOK_ECSTABLE_BODY[[]]m4_dnl
};
]])

m4_ifdef( [[M4_MODE_USEMECS]],[[m4_dnl
/* Character meta-equivalence-class mappings */
static const YY_CHAR yy_meta[M4_HOOK_MECSTABLE_SIZE] = { 0,
M4_HOOK_MECSTABLE_BODY[[]]m4_dnl
};
]])

m4_ifdef( [[M4_HOOK_TRANSTABLE_SIZE]],[[m4_dnl
/* The transition table */
static const struct yy_trans_info yy_transition[M4_HOOK_TRANSTABLE_SIZE] = {
M4_HOOK_TRANSTABLE_BODY[[]]m4_dnl
};
]])

m4_ifdef( [[M4_HOOK_STARTTABLE_SIZE]],[[m4_dnl
/* Table of pointers to start states. */
static const struct yy_trans_info *yy_start_state_list[M4_HOOK_STARTTABLE_SIZE] = {
M4_HOOK_STARTTABLE_BODY[[]]m4_dnl
};
]])

m4_ifdef( [[M4_HOOK_ACCLIST_TYPE]],[[m4_dnl
static const M4_HOOK_ACCLIST_TYPE yy_acclist[M4_HOOK_ACCLIST_SIZE] = { 0,
M4_HOOK_ACCLIST_BODY[[]]m4_dnl
};
]])

m4_ifdef( [[M4_HOOK_BASE_TYPE]],[[m4_dnl
static const M4_HOOK_BASE_TYPE yy_base[M4_HOOK_BASE_SIZE] = { 0,
M4_HOOK_BASE_BODY[[]]m4_dnl
};
]])

m4_ifdef( [[M4_HOOK_DEF_TYPE]],[[m4_dnl
static const M4_HOOK_DEF_TYPE yy_def[M4_HOOK_DEF_SIZE] = { 0,
M4_HOOK_DEF_BODY[[]]m4_dnl
};
]])

m4_ifdef( [[M4_HOOK_YYNXT_TYPE]],[[m4_dnl
static const M4_HOOK_YYNXT_TYPE yy_nxt[M4_HOOK_YYNXT_SIZE] = { 0,
M4_HOOK_YYNXT_BODY[[]]m4_dnl
};
]])

m4_ifdef( [[M4_HOOK_CHK_TYPE]],[[m4_dnl
static const M4_HOOK_CHK_TYPE yy_chk[M4_HOOK_CHK_SIZE] = { 0,
M4_HOOK_CHK_BODY[[]]m4_dnl
};
]])

m4_ifdef( [[M4_HOOK_NULTRANS_SIZE]],[[m4_dnl
static const yy_state_type yy_NUL_trans[M4_HOOK_NULTRANS_SIZE] = { 0,
M4_HOOK_NULTRANS_BODY[[]]m4_dnl
};
]])

m4_ifdef( [[M4_MODE_DEBUG]],[[m4_dnl
/* Rule to line-number mapping */
static const M4_HOOK_DEBUGTABLE_TYPE yy_rule_linenum[M4_HOOK_DEBUGTABLE_SIZE] = { 0,
M4_HOOK_DEBUGTABLE_BODY[[]]m4_dnl
};
]])

%% [3.0] static declarations conditional on mode switches go here

M4_YY_SC_DEFS

typedef struct yy_buffer_state *yybuffer;

%# These are not part of the exported interface and can safely be renamed
/* These must be #defines, not const variables, because they're used as case
 * arm values. GCC will allow case arm expressions to include references to
 * const variables, but this is not standard-conformant and other compilers
 * may not.
 */
#define EOB_ACT_CONTINUE_SCAN	0
#define EOB_ACT_END_OF_FILE	1
#define EOB_ACT_LAST_MATCH	2
#define YY_BUFFER_NEW		0
#define YY_BUFFER_NORMAL	1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING	2

struct yy_buffer_state {
	FILE *yy_input_file;
	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	int yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	bool yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use char-by-char
	 * rather than a buffered read, to make sure we stop fetching input after
	 * each newline.
	 */
	bool yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	bool yyatbol_flag;

	int bs_yylineno; /**< The line count. */
	int bs_yycolumn; /**< The column count. */

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	bool yy_fill_buffer;

	int yy_buffer_status;
};

/* Watch out: yytext_ptr is a variable when yytext is an array,
 * but it's a macro when yytext is a pointer.
 */
m4_ifdef([[M4_MODE_NO_YYTEXT_IS_ARRAY]], [[
m4_define([[yytext_ptr]], [[yytext_r]])
]])

m4_ifdef( [[M4_MODE_VARIABLE_TRAILING_CONTEXT_RULES]], [[m4_dnl
%# These must match the values in the file flexdef.h
%# of the flex source code, otherwise havoc will ensue.
const int YY_TRAILING_MASK = 0x2000;
const int YY_TRAILING_HEAD_MASK = 0x4000;
]])
/* Holds the entire state of the reentrant scanner. */
struct yyguts_t {
	/* User-defined. Not touched by flex. */
	m4_ifdef([[M4_MODE_EXTRA_TYPE]], [[M4_MODE_EXTRA_TYPE yyextra_r;]])

	/* The rest are the same as the globals declared in the non-reentrant scanner. */
	FILE *yyin_r, *yyout_r;
	size_t yy_buffer_stack_top; /**< index of top of stack. */
	size_t yy_buffer_stack_max; /**< capacity of stack. */
	yybuffer * yy_buffer_stack; /**< Stack as an array. */
	char yy_hold_char;
	int yy_n_chars;
	int yyleng_r;
	char *yy_c_buf_p;
	bool yy_init;
	int yy_start;
	bool yy_did_buffer_switch_on_eof;
	int yy_start_stack_ptr;
	int yy_start_stack_depth;
	int *yy_start_stack;
	yy_state_type yy_last_accepting_state;
	char* yy_last_accepting_cpos;

	int yylineno_r;
	int yyflexdebug_r;

m4_ifdef( [[M4_MODE_USES_REJECT]], [[
	yy_state_type *yy_state_buf;
	yy_state_type *yy_state_ptr;
	size_t yy_state_buf_max;
	char *yy_full_match;
	int yy_lp;

m4_ifdef( [[M4_MODE_VARIABLE_TRAILING_CONTEXT_RULES]], [[m4_dnl
	/* These are only needed for trailing context rules */
	int yy_looking_for_trail_begin;
	int yy_full_lp;
	int *yy_full_state;
]])
]])
m4_ifdef( [[M4_MODE_YYTEXT_IS_ARRAY]], [[
	char yytext_r[YYLMAX];
	char *yytext_ptr;
	int yy_more_offset;
	int yy_prev_more_offset;
]], [[
	char *yytext_r;
	bool yy_more_flag;
	int yy_more_len;
]])
m4_ifdef( [[M4_YY_BISON_LVAL]], [[
	YYSTYPE * yylval_r;
]])

m4_ifdef( [[<M4_YY_BISON_LLOC>]], [[
	YYLTYPE * yylloc_r;
]])
}; /* end struct yyguts_t */

m4_ifdef( [[M4_YY_BISON_LVAL]],
[[
/* This must go here because YYSTYPE and YYLTYPE are included
 * from bison output in section 1.*/
m4_define([[yylval]], [[yyscanner->yylval_r]])
]])

m4_ifdef( [[<M4_YY_BISON_LLOC>]],
[[
m4_define([[yylloc]], [[yyscanner->yylloc_r]])
]])

m4_ifdef( [[M4_YY_NO_FLEX_ALLOC]],,
[[
void *yyalloc(size_t size, yyscan_t yyscanner) {
	(void)yyscanner; /* forestall unused-argument warning */
	return malloc(size);
}
]])

m4_ifdef( [[M4_YY_NO_FLEX_REALLOC]],,
[[
void *yyrealloc(void * ptr, size_t size, yyscan_t yyscanner) {
	(void)yyscanner; /* forestall unused-argument warning */
	return realloc(ptr, size);
}
]])

m4_ifdef( [[M4_YY_NO_FLEX_FREE]],,
[[
void yyfree(void * ptr, yyscan_t yyscanner) {
	(void)yyscanner; /* forestall unused-argument warning */
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	free( (char *) ptr );
}
]])

m4_ifdef( [[M4_MODE_NO_YYWRAP]], [[
int M4_MODE_PREFIX[[wrap]](yyscan_t yyscanner) {
	return /*CONSTCOND*/1;
}
]])

/* Helpers for special functions, also part of public API */

/* Returns the top of the stack, or NULL. */
yybuffer yy_current_buffer(yyscan_t yyscanner) {
	  return ( yyscanner->yy_buffer_stack					\
		   ? yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top] \
		   : NULL);
}

static void yy_load_buffer_state  (yyscan_t yyscanner)
{
	yyscanner->yy_n_chars = yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_n_chars;
	yyscanner->yytext_ptr = yyscanner->yy_c_buf_p = yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_buf_pos;
	yyscanner->yyin_r = yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_input_file;
	yyscanner->yy_hold_char = *yyscanner->yy_c_buf_p;
}

/** Discard all buffered characters. On the next scan, yyread() will be called.
 * @param b the buffer state to be flushed, usually @c yy_current_buffer(yyscanner).
 * @param yyscanner The scanner object.
 */
void yy_flush_buffer(yybuffer b, yyscan_t yyscanner)
{
	if ( b == NULL ) {
		return;
	}
	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yyatbol_flag = true;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == yy_current_buffer(yyscanner) ) {
		yy_load_buffer_state( yyscanner );
	}
}

void yy_flush_current_buffer(yyscan_t yyscanner) {
	yy_flush_buffer( yy_current_buffer(yyscanner), yyscanner);
}

const int YY_EXIT_FAILURE = 2;

m4_ifdef( [[M4_YY_NO_YYPANIC]],, [[
/* This function has a magic rewrite rule */
static void yynoreturn yypanic(const char* msg, yyscan_t yyscanner) {
	(void)yyscanner; /* forestall unused-argument warning */
	fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
}
]])

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack (yyscan_t yyscanner)
{
	size_t num_to_alloc;

	if (yyscanner->yy_buffer_stack == NULL) {
		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
		 */
		num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
		yyscanner->yy_buffer_stack = (struct yy_buffer_state**)yyalloc
			(num_to_alloc * sizeof(struct yy_buffer_state*), yyscanner);
		if ( yyscanner->yy_buffer_stack == NULL ) {
			yypanic( "out of dynamic memory in yyensure_buffer_stack()", yyscanner );
		}

		memset(yyscanner->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

		yyscanner->yy_buffer_stack_max = num_to_alloc;
		yyscanner->yy_buffer_stack_top = 0;
		return;
	}

	if (yyscanner->yy_buffer_stack_top >= (yyscanner->yy_buffer_stack_max) - 1) {
		/* Increase the buffer to prepare for a possible push. */
		size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = yyscanner->yy_buffer_stack_max + grow_size;
		yyscanner->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc
								(yyscanner->yy_buffer_stack,
								 num_to_alloc * sizeof(struct yy_buffer_state*),
								yyscanner);
		if (yyscanner->yy_buffer_stack == NULL) {
			yypanic( "out of dynamic memory in yyensure_buffer_stack()", yyscanner );
		}
		/* zero only the new slots.*/
		memset(yyscanner->yy_buffer_stack + yyscanner->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
		yyscanner->yy_buffer_stack_max = num_to_alloc;
	}
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
static void yy_init_buffer(yybuffer  b, FILE * file, yyscan_t yyscanner)
{
	int oerrno = errno;

	yy_flush_buffer( b, yyscanner);

	b->yy_input_file = file;
	if (b->yy_input_file == NULL) {
	  b->yy_fill_buffer = false;
	} else {
	  b->yy_fill_buffer = true;
	}

	/* If b is the current buffer, then yy_init_buffer was _probably_
	 * called from yyrestart() or through yy_get_next_buffer.
	 * In that case, we don't want to reset the lineno or column.
	 */
	if (b != yy_current_buffer(yyscanner)) {
		b->bs_yylineno = 1;
		b->bs_yycolumn = 0;
	}

m4_ifdef( [[M4_YY_ALWAYS_INTERACTIVE]],
[[
	b->yy_is_interactive = true;
]],
[[
    m4_ifdef( [[M4_YY_NEVER_INTERACTIVE]],
    [[
    	b->yy_is_interactive = false;
    ]],
    [[
	b->yy_is_interactive = (file != NULL) && (isatty( fileno(file) ) > 0);
    ]])
]])
    	errno = oerrno;
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * @param yyscanner The scanner object.
 * @return the allocated buffer state.
 */
yybuffer yy_create_buffer(FILE * file, int  size, yyscan_t yyscanner)
{
	yybuffer b;

	b = (yybuffer) yyalloc( sizeof( struct yy_buffer_state ), yyscanner );
	if (  b == NULL ) {
		yypanic( "out of dynamic memory in yy_create_buffer()", yyscanner );
	}
	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yyalloc( (size_t) (b->yy_buf_size + 2), yyscanner );
	if ( b->yy_ch_buf == NULL ) {
		yypanic( "out of dynamic memory in yy_create_buffer()", yyscanner );
	}
	b->yy_is_our_buffer = true;

	yy_init_buffer( b, file, yyscanner);

	return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * @param yyscanner The scanner object.
 */
void yy_delete_buffer(yybuffer b, yyscan_t yyscanner)
{

	if ( b == NULL ) {
		return;
	}
	if ( b == yy_current_buffer(yyscanner) ) {	/* Not sure if we should pop here. */
		yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top] = (yybuffer) 0;
	}
	if ( b->yy_is_our_buffer ) {
		yyfree( (void *) b->yy_ch_buf, yyscanner );
	}
	yyfree( (void *) b, yyscanner );
}


/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  @param yyscanner The scanner object.
 */
void yypush_buffer_state(yybuffer new_buffer, yyscan_t yyscanner)
{
	if (new_buffer == NULL) {
		return;
	}
	yyensure_buffer_stack(yyscanner);

	/* This block is copied from yy_switch_to_buffer. */
	if ( yy_current_buffer(yyscanner) != NULL ) {
		/* Flush out information for old buffer. */
		*yyscanner->yy_c_buf_p = yyscanner->yy_hold_char;
		yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_buf_pos = yyscanner->yy_c_buf_p;
		yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_n_chars = yyscanner->yy_n_chars;
	}

	/* Only push if top exists. Otherwise, replace top. */
	if (yy_current_buffer(yyscanner)) {
		yyscanner->yy_buffer_stack_top++;
	}
	yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top] = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state( yyscanner );
	yyscanner->yy_did_buffer_switch_on_eof = true;
}


/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  @param yyscanner The scanner object.
 */
void yypop_buffer_state (yyscan_t yyscanner)
{
	if (yy_current_buffer(yyscanner) == NULL) {
		return;
	}
	yy_delete_buffer(yy_current_buffer(yyscanner), yyscanner);
	yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top] = NULL;
	if (yyscanner->yy_buffer_stack_top > 0) {
		--yyscanner->yy_buffer_stack_top;
	}
	if (yy_current_buffer(yyscanner) != NULL) {
		yy_load_buffer_state( yyscanner );
		yyscanner->yy_did_buffer_switch_on_eof = true;
	}
}


/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * @param yyscanner The scanner object.
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyrestart(FILE * input_file, yyscan_t yyscanner)
{
m4_ifdef( [[M4_MODE_USES_REJECT]], [[
	size_t new_size = 0;
	yy_state_type *new_state_buf = 0;
]] )

	if ( yy_current_buffer(yyscanner) == NULL ) {
		yyensure_buffer_stack (yyscanner);
		yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top] =
			yy_create_buffer( yyscanner->yyin_r, YY_BUF_SIZE, yyscanner);
	}

	yy_init_buffer( yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top], input_file, yyscanner);
	yy_load_buffer_state( yyscanner );

m4_ifdef( [[M4_MODE_USES_REJECT]], [[
	/* Ensure the reject state buffer is large enough.
	 */
	if ( yyscanner->yy_state_buf_max < (size_t) (yy_current_buffer(yyscanner)->yy_buf_size + YY_STATE_BUF_EXTRA_SPACE) ) {
		new_size = yy_current_buffer(yyscanner)->yy_buf_size + YY_STATE_BUF_EXTRA_SPACE;
		new_state_buf = (yy_state_type*) yyrealloc( yyscanner->yy_state_buf, (new_size * sizeof(yy_state_type)), yyscanner );

		if ( new_state_buf == NULL ) {
			yypanic( "out of dynamic memory in yylex()", yyscanner );
		}
		else {
			yyscanner->yy_state_buf = new_state_buf;
			yyscanner->yy_state_buf_max = new_size;
		}
	}
]] )

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	yyscanner->yy_did_buffer_switch_on_eof = true;
}

static void yybumpline( yyscan_t yyscanner) {
	yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->bs_yylineno++;
        yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->bs_yycolumn=0;
}

/* START special functions
 *
 * Flex's scanner knows these are special and inserts the yyscanner argument
 * at the end of the argument list.  TODO: support OO languages with a
 * property that causes it to be prepended with a dot instead.
 */

/* Enter a start condition. */
void yybegin(int s, yyscan_t yyscanner) {
	yyscanner->yy_start = 1 + 2 * (s);
}

/* Translate the current start state into a value that can be later handed
 * to yybegin() to return to the state.
 */
int yystart(yyscan_t yyscanner) {
	return ((yyscanner->yy_start - 1) / 2);
}

/* This used to be an fputs(), but since the string might contain NULs,
 * we now use fwrite().
 */
void yyecho(yyscan_t yyscanner) {
	fwrite(yyscanner->yytext_r, (size_t) yyscanner->yyleng_r, 1, yyscanner->yyout_r);
}

m4_ifdef( [[M4_YY_NO_YYUNPUT]],, [[
void yyunput(char c, yyscan_t yyscanner)
{
	char *yy_cp;

	yy_cp = yyscanner->yy_c_buf_p;

	/* undo effects of setting up yytext */
	*yy_cp = yyscanner->yy_hold_char;

	if ( yy_cp < yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf + 2 ) {
		/* need to shift things up to make room */
		/* +2 for EOB chars. */
		int number_to_move = yyscanner->yy_n_chars + 2;
		char *dest = &yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf[
					yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_buf_size + 2];
		char *source =
				&yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf[number_to_move];

		while ( source > yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf ) {
			*--dest = *--source;
		}
		yy_cp += (int) (dest - source);
		yyscanner->yytext_ptr += (int) (dest - source);
		yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_n_chars =
			yyscanner->yy_n_chars = (int) yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_buf_size;

		if ( yy_cp < yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf + 2 ) {
			yypanic( "flex scanner push-back overflow", yyscanner);
		}
	}

	*--yy_cp = c;

m4_ifdef( [[M4_MODE_YYLINENO]],
[[
	if ( c == '\n' ){
		yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->bs_yylineno--;
	}
]])

	yyscanner->yy_hold_char = *yy_cp;
	yyscanner->yy_c_buf_p = yy_cp;
}
]])

%# yymore has a magic rewrite rule. It's declared here, rather than with the other
%# magic functions, so yy_get_next_buffer() won't need a forward declaration.
m4_ifdef([[M4_MODE_YYMORE_USED]], [[
m4_ifdef( [[M4_MODE_YYTEXT_IS_ARRAY]], [[
void yymore(yyscan_t yyscanner) {yyscanner->yy_more_offset = strlen(yyscanner->yytext_r);}
m4_define([[YY_MORE_ADJ]],  [[0]])
m4_define([[YY_RESTORE_YY_MORE_OFFSET]], [[{
yyscanner->yy_more_offset = yyscanner->yy_prev_more_offset;
yyscanner->yyleng_r -= yyscanner->yy_more_offset;
}
]])
]])
m4_ifdef( [[M4_MODE_NO_YYTEXT_IS_ARRAY]], [[
void yymore(yyscan_t yyscanner) {yyscanner->yy_more_flag = true;}
m4_define([[YY_MORE_ADJ]],  [[yyscanner->yy_more_len]])
m4_define([[YY_RESTORE_YY_MORE_OFFSET]], [[]])
]])
]])

m4_ifdef([[M4_MODE_NO_YYMORE_USED]], [[
m4_define([[YY_MORE_ADJ]],  [[0]])
m4_define([[YY_RESTORE_YY_MORE_OFFSET]], [[]])
]])

m4_ifdef( [[M4_MODE_USER_YYREAD]],, [[
/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
static int yyread(char *buf, size_t max_size, yyscan_t yyscanner) {
	int result;
m4_ifdef( [[M4_MODE_CPP_USE_READ]], [[
	errno=0;
	while ( (result = (int) read( fileno(yyscanner->yyin_r), buf, (size_t) max_size )) < 0 ) {
		if( errno != EINTR) {
			yypanic( "input in flex scanner failed", yyscanner);
			break;
		}
		errno=0;
		clearerr(yyscanner->yyin_r);
	}
]])
m4_ifdef( [[M4_MODE_NO_CPP_USE_READ]], [[
	if ( yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_is_interactive ) {
		int c = '*';
		size_t n;
		for ( n = 0; n < max_size &&
			      (c = getc( yyscanner->yyin_r )) != EOF && c != '\n'; ++n ) {
			buf[n] = (char) c;
		}
		if ( c == '\n' ) {
			buf[n++] = (char) c;
		}
		if ( c == EOF && ferror( yyscanner->yyin_r ) ) {
			yypanic( "input in flex scanner failed", yyscanner);
		}
		result = n;
	} else {
		errno=0;
		while ( (result = (int) fread(buf, 1, (size_t) max_size, yyscanner->yyin_r)) == 0 && ferror(yyscanner->yyin_r)) {
			if( errno != EINTR) {
				yypanic( "input in flex scanner failed", yyscanner);
				break;
			}
			errno=0;
			clearerr(yyscanner->yyin_r);
		}
	}
]])
	 return result;
}
]])

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
	char *dest = yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf;
	char *source = yyscanner->yytext_ptr;
	int number_to_move, i;
	int ret_val;

	if ( yyscanner->yy_c_buf_p > &yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf[yyscanner->yy_n_chars + 1] ) {
		yypanic( "fatal flex scanner internal error--end of buffer missed", yyscanner);
	}
	if ( !yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_fill_buffer ) {
		/* Don't try to fill the buffer, so this is an EOF. */
		if ( yyscanner->yy_c_buf_p - yyscanner->yytext_ptr - YY_MORE_ADJ == 1 ) {
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
		} else {
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
		}
	}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) (yyscanner->yy_c_buf_p - yyscanner->yytext_ptr - 1);

	if (number_to_move > 0)
		memmove(dest, source, number_to_move * sizeof(*source));

	if ( yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_buffer_status == YY_BUFFER_EOF_PENDING ) {
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_n_chars = yyscanner->yy_n_chars = 0;
	} else {
		int num_to_read =
			yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 ) { /* Not enough room in the buffer - grow it. */
m4_ifdef( [[M4_MODE_USES_REJECT]],
[[
			yypanic(
				"input buffer overflow, can't enlarge buffer because scanner uses reject", yyscanner );
]],
[[
			/* just a shorter name for the current buffer */
			yybuffer b = yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top];

			int yy_c_buf_p_offset =
				(int) (yyscanner->yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer ) {
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 ) {
					b->yy_buf_size += b->yy_buf_size / 8;
				} else {
					b->yy_buf_size *= 2;
				}
				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yyrealloc( (void *) b->yy_ch_buf,
							 (size_t) (b->yy_buf_size + 2), yyscanner );
			} else {
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;
			}
			if ( b->yy_ch_buf == NULL ) {
				yypanic("fatal error - scanner input buffer overflow", yyscanner);
			}
			yyscanner->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_buf_size -
						number_to_move - 1;
]])
		}

		if ( num_to_read > YY_READ_BUF_SIZE ) {
			num_to_read = YY_READ_BUF_SIZE;
		}
		/* Read in more data. */
		yyscanner->yy_n_chars = yyread(&yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf[number_to_move], num_to_read, yyscanner);

		yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_n_chars = yyscanner->yy_n_chars;
	}

	if ( yyscanner->yy_n_chars == 0 ) {
		if ( number_to_move == YY_MORE_ADJ ) {
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyscanner->yyin_r, yyscanner);
		} else {
			ret_val = EOB_ACT_LAST_MATCH;
			yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
		}
	} else {
		ret_val = EOB_ACT_CONTINUE_SCAN;
	}
	if ((yyscanner->yy_n_chars + number_to_move) > yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = yyscanner->yy_n_chars + number_to_move + (yyscanner->yy_n_chars >> 1) + 2;
		yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf = (char *) yyrealloc(
			(void *) yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf, (size_t) new_size, yyscanner );
		if ( yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf == NULL ) {
			yypanic( "out of dynamic memory in yy_get_next_buffer()", yyscanner);
		}
		/* "- 2" to take care of EOB's */
		yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_buf_size = (int) (new_size - 2);
	}

	yyscanner->yy_n_chars += number_to_move;
	yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf[yyscanner->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf[yyscanner->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yyscanner->yytext_ptr = &yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf[0];

	return ret_val;
}

int yyinput (yyscan_t yyscanner)
{
	int c;

	*yyscanner->yy_c_buf_p = yyscanner->yy_hold_char;

	if ( *yyscanner->yy_c_buf_p == YY_END_OF_BUFFER_CHAR ) {
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( yyscanner->yy_c_buf_p < &yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf[yyscanner->yy_n_chars] ) {
			/* This was really a NUL. */
			*yyscanner->yy_c_buf_p = '\0';
		} else {
			/* need more input */
			int offset = (int) (yyscanner->yy_c_buf_p - yyscanner->yytext_ptr);
			++yyscanner->yy_c_buf_p;

			switch ( yy_get_next_buffer( yyscanner ) ) {
			case EOB_ACT_LAST_MATCH:
				/* This happens because yy_g_n_b()
				 * sees that we've accumulated a
				 * token and flags that we need to
				 * try matching the token before
				 * proceeding.  But for input(),
				 * there's no matching to consider.
				 * So convert the EOB_ACT_LAST_MATCH
				 * to EOB_ACT_END_OF_FILE.
				 */

				/* Reset buffer status. */
				yyrestart( yyscanner->yyin_r, yyscanner);

				/*FALLTHROUGH*/

			case EOB_ACT_END_OF_FILE:
				if ( yywrap( yyscanner ) ) {
					return 0;
				}
				if ( ! yyscanner->yy_did_buffer_switch_on_eof ) {
					yyrestart( yyscanner->yyin_r, yyscanner );
				}
				return yyinput(yyscanner);

			case EOB_ACT_CONTINUE_SCAN:
				yyscanner->yy_c_buf_p = yyscanner->yytext_ptr + offset;
				break;
			default:
				yypanic("unexpected return value from yy_get_next_buffer()", yyscanner);
			}
		}
	}

	c = *(unsigned char *) yyscanner->yy_c_buf_p;	/* cast for 8-bit char's */
	*yyscanner->yy_c_buf_p = '\0';	/* preserve yytext */
	yyscanner->yy_hold_char = *++yyscanner->yy_c_buf_p;

m4_ifdef([[M4_MODE_BOL_NEEDED]], [[
	yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yyatbol_flag = (c == '\n');
m4_ifdef([[M4_MODE_YYLINENO]], [[
	if ( yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yyatbol_flag ) {
		yybumpline( yyscanner );
	}
]])
]])
m4_ifdef([[M4_MODE_NO_BOL_NEEDED]], [[
m4_ifdef([[M4_MODE_YYLINENO]], [[
	if ( c == '\n' ) {
		yybumpline( yyscanner );
	}
	]])
]])

	return c;
}

/* ENDS special functions

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

m4_ifdef( [[M4_MODE_NO_YYWRAP]],, [[
extern int yywrap ( yyscan_t yyscanner );
]])

m4_ifdef( [[M4_YY_STACK_USED]],
[[
    m4_ifdef( [[M4_YY_NO_PUSH_STATE]],,
    [[
    static void yy_push_state ( int _new_state, yyscan_t yyscanner);
    ]])
    m4_ifdef( [[M4_YY_NO_POP_STATE]],,
    [[
    static void yy_pop_state ( yyscan_t yyscanner );
    ]])
    m4_ifdef( [[M4_YY_NO_TOP_STATE]],,
    [[
    static int yy_top_state ( yyscan_t yyscanner );
    ]])
]],
[[
m4_define( [[M4_YY_NO_PUSH_STATE]])
m4_define( [[M4_YY_NO_POP_STATE]])
m4_define( [[M4_YY_NO_TOP_STATE]])
]])

/* STARTS Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

m4_ifdef([[M4_MODE_EXTRA_TYPE]], [[m4_dnl
m4_ifdef([[M4_YY_NO_GET_EXTRA]],, [[m4_dnl
/** Get the user-defined data for this scanner.
 * @param yyscanner The scanner object.
 */
M4_MODE_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner) {
	return yyscanner->yyextra_r;
}
]])
]])

m4_ifdef( [[M4_YY_NO_GET_LINENO]],,
[[
/** Get the current line number.
 * @param yyscanner The scanner object.
 */
int yyget_lineno  (yyscan_t yyscanner) {
	yybuffer cb = yy_current_buffer(yyscanner);

	if (cb == NULL) {
		return 0;
	}
	return cb->bs_yylineno;
}
]])

m4_ifdef( [[M4_YY_NO_GET_COLUMN]],,
[[
/** Get the current column number.
 * @param yyscanner The scanner object.
 */
int yyget_column  (yyscan_t yyscanner) {
	yybuffer cb = yy_current_buffer(yyscanner);

	if (cb == NULL) {
		return 0;
	}
	return cb->bs_yycolumn;
}
]])

m4_ifdef( [[M4_YY_NO_GET_IN]],,
[[
/** Get the input stream.
 * @param yyscanner The scanner object.
 */
FILE *yyget_in  (yyscan_t yyscanner) {
	return yyscanner->yyin_r;
}
]])

m4_ifdef( [[M4_YY_NO_GET_OUT]],,
[[
/** Get the output stream.
 * @param yyscanner The scanner object.
 */
FILE *yyget_out  (yyscan_t yyscanner) {
	return yyscanner->yyout_r;
}
]])

m4_ifdef( [[M4_YY_NO_GET_LENG]],,
[[
/** Get the length of the current token.
 * @param yyscanner The scanner object.
 */
int yyget_leng  (yyscan_t yyscanner) {
	return yyscanner->yyleng_r;
}
]])

/** Get the current token.
 * @param yyscanner The scanner object.
 */
m4_ifdef( [[M4_YY_NO_GET_TEXT]],,
[[
char *yyget_text  (yyscan_t yyscanner) {
	return yyscanner->yytext_r;
}
]])

m4_ifdef([[M4_MODE_EXTRA_TYPE]], [[m4_dnl
m4_ifdef( [[M4_YY_NO_SET_EXTRA]],,
[[
/** Set the user-defined data. This data is never touched by the scanner.
 * @param user_defined The data to be associated with this scanner.
 * @param yyscanner The scanner object.
 */
void yyset_extra(M4_MODE_EXTRA_TYPE user_defined, yyscan_t yyscanner) {
	yyscanner->yyextra_r = user_defined ;
}
]])
]])

m4_ifdef( [[M4_YY_NO_SET_LINENO]],,
[[
/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void yyset_lineno(int _line_number, yyscan_t yyscanner) {
	yybuffer cb = yy_current_buffer(yyscanner);

	/* lineno is only valid if an input buffer exists. */
	if (cb == NULL ) {
		yypanic( "yyset_lineno called with no buffer", yyscanner );
	}
	cb->bs_yylineno = _line_number;
}
]])

m4_ifdef( [[M4_YY_NO_SET_COLUMN]],,
[[
/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void yyset_column(int _column_no, yyscan_t yyscanner) {
	yybuffer cb = yy_current_buffer(yyscanner);

	/* column is only valid if an input buffer exists. */
	if (cb == NULL ) {
		yypanic( "yyset_column called with no buffer", yyscanner );
	}
	cb->bs_yycolumn = _column_no;
}
]])

m4_ifdef( [[M4_YY_NO_SET_IN]],,
[[
/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see yy_switch_to_buffer
 */
void yyset_in(FILE * _in_str, yyscan_t yyscanner) {
	yyscanner->yyin_r = _in_str ;
}
]])

m4_ifdef( [[M4_YY_NO_SET_OUT]],,
[[
void yyset_out( FILE * _out_str, yyscan_t yyscanner) {
	yyscanner->yyout_r = _out_str ;
}
]])


m4_ifdef( [[M4_YY_NO_GET_DEBUG]],,
[[
int yyget_debug  (yyscan_t yyscanner) {
	return yyscanner->yyflexdebug_r;
}
]])

m4_ifdef( [[M4_YY_NO_SET_DEBUG]],,
[[
void yyset_debug(int _bdebug, yyscan_t yyscanner) {
	yyscanner->yyflexdebug_r = _bdebug ;
}
]])

m4_ifdef([[M4_YY_BISON_LVAL]], [[
m4_ifdef( [[M4_YY_NO_GET_LVAL]],,
[[
YYSTYPE * yyget_lval  (yyscan_t yyscanner) {
	return yylval;
}
]])

m4_ifdef( [[M4_YY_NO_SET_LVAL]],,
[[
void yyset_lval(YYSTYPE *yylval_param, yyscan_t yyscanner) {
	yylval = yylval_param;
}
]])

m4_ifdef( [[<M4_YY_BISON_LLOC>]],
[[
m4_ifdef( [[M4_YY_NO_GET_LLOC]],,
[[
YYLTYPE *yyget_lloc  (yyscan_t yyscanner) {
	return yylloc;
}
]])

m4_ifdef( [[M4_YY_NO_SET_LLOC]],,
[[
void yyset_lloc(YYLTYPE *yylloc_param, yyscan_t yyscanner) {
	yylloc = yylloc_param;
}
]])
]])

]])

/* ENDS public accessor functions */

/* Number of entries by which start-condition stack grows. */
const int YY_START_STACK_INCR = 25;

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
m4_ifdef([[YY_DECL]],, [[m4_dnl
m4_define( [[M4_YY_LEX_PROTO]], [[(yyscan_t yyscanner)]])
m4_define( [[M4_YY_LEX_DECLARATION]], [[(yyscan_t yyscanner)]])

m4_ifdef( [[M4_YY_BISON_LVAL]],
[[
    m4_dnl  The bison pure parser is used. Redefine yylex to
    m4_dnl  accept the lval parameter.

    m4_define( [[M4_YY_LEX_PROTO]], [[\]]
               [[(YYSTYPE * yylval_param, yyscan_t yyscanner)]])
    m4_define( [[M4_YY_LEX_DECLARATION]], [[\]]
					   [[(YYSTYPE * yylval_param, yyscan_t yyscanner)]])
]])

m4_ifdef( [[<M4_YY_BISON_LLOC>]],
[[
    m4_dnl  Locations are used. yylex should also accept the ylloc parameter.

    m4_define( [[M4_YY_LEX_PROTO]], [[\]]
               [[(YYSTYPE * yylval_param, YYLTYPE * yylloc_param, yyscan_t yyscanner)]])
    m4_define( [[M4_YY_LEX_DECLARATION]], [[\]]
					   [[(YYSTYPE *yylval_param, YYLTYPE *yylloc_param, yyscan_t yyscanner)]])
]])

extern int yylex M4_YY_LEX_PROTO;

m4_define([[YY_DECL]], [[int yylex M4_YY_LEX_DECLARATION]])
]])

m4_ifdef([[M4_MODE_BOL_NEEDED]], [[
static void rule_check_bol(yyscan_t yyscanner) {
	if ( yyscanner->yyleng_r > 0 ) {		\
		yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yyatbol_flag = (yyscanner->yytext_r[yyscanner->yyleng_r - 1] == '\n');
	}
}
]])

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.  yy_cp and yy_bp are the
 * end abd start pointers for the input buffer segment that is
 * claimed as yytext.
 */
void yy_do_before_action(yyscan_t yyscanner, char *yy_cp, char *yy_bp) {
	yyscanner->yytext_ptr = yy_bp; \
	m4_ifdef([[M4_MODE_YYMORE_USED]], [[m4_ifdef([[M4_MODE_NO_YYTEXT_IS_ARRAY]], [[yyscanner->yytext_ptr -= yyscanner->yy_more_len; \
	yyscanner->yyleng_r = (int) (yy_cp - yyscanner->yytext_ptr);]])]]) \
	m4_ifdef([[M4_MODE_NO_YYMORE_USED]], [[yyscanner->yyleng_r = (int) (yy_cp - yy_bp);]]) \
	m4_ifdef([[M4_MODE_YYTEXT_IS_ARRAY]], [[yyscanner->yyleng_r = (int) (yy_cp - yy_bp);]]) \
	yyscanner->yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
m4_ifdef([[M4_MODE_YYTEXT_IS_ARRAY]], [[ \
	m4_ifdef([[M4_MODE_YYMORE_USED]], [[if ( yyscanner->yyleng_r + yyscanner->yy_more_offset >= YYLMAX ) \
					 yypanic( "token too large, exceeds YYLMAX", yyscanner);]]) \
	m4_ifdef([[M4_MODE_NO_YYMORE_USED]], [[if ( yyscanner->yyleng_r >= YYLMAX ) \
					 yypanic( "token too large, exceeds YYLMAX", yyscanner);]]) \
	m4_ifdef([[M4_MODE_YYMORE_USED]], [[strncpy( &yyscanner->yytext_r[yyscanner->yy_more_offset], yyscanner->yytext_ptr, yyscanner->yyleng_r + 1);]]) \
	m4_ifdef([[M4_MODE_YYMORE_USED]], [[yyscanner->yyleng_r += yyscanner->yy_more_offset;]]) \
	m4_ifdef([[M4_MODE_YYMORE_USED]], [[yyscanner->yy_prev_more_offset = yyscanner->yy_more_offset;]]) \
	m4_ifdef([[M4_MODE_YYMORE_USED]], [[yyscanner->yy_more_offset = 0;]]) \
	m4_ifdef([[M4_MODE_NO_YYMORE_USED]], [[strncpy( yyscanner->yytext_r, yyscanner->yytext_ptr, yyscanner->yyleng_r + 1);]]) \
]]) \
	yyscanner->yy_c_buf_p = yy_cp;
}

m4_ifdef( [[M4_MODE_YYLINENO]], [[
/* FIXME: gate on yy_rule_can_match_eol, this is no longer a macro
 * and we can get at yy_act */
static void yy_less_lineno(int n, yyscan_t yyscanner) {
	int yyl;
	for ( yyl = n; yyl < yyscanner->yyleng_r; ++yyl ) {
		if ( yyscanner->yytext_r[yyl] == '\n' ) {
			yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->bs_yylineno--;
		}
	}
}

static void yy_lineno_rewind_to(char *yy_cp, char *dst, yyscan_t yyscanner)  {
	const char *p;
	for ( p = yy_cp-1; p >= dst; --p) {
		if ( *p == '\n' ) {
			yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->bs_yylineno--;
		}
	}
}
]])

void yy_set_interactive(bool is_interactive, yyscan_t yyscanner) {
	if ( yy_current_buffer(yyscanner) == NULL ) {
		yyensure_buffer_stack (yyscanner);
		yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top] =
			yy_create_buffer( yyscanner->yyin_r, YY_BUF_SIZE, yyscanner);
	}
	yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_is_interactive = is_interactive;
}


void yysetbol(bool at_bol, yyscan_t yyscanner) {
	if ( yy_current_buffer(yyscanner) == NULL ) {
		yyensure_buffer_stack (yyscanner);
		yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top] =
        		yy_create_buffer( yyscanner->yyin_r, YY_BUF_SIZE, yyscanner);
	}
	yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yyatbol_flag = at_bol;
}

bool yyatbol(yyscan_t yyscanner) {
	return (yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yyatbol_flag);
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * @param yyscanner The scanner object.
 */
void yy_switch_to_buffer(yybuffer new_buffer, yyscan_t yyscanner)
{
m4_ifdef( [[M4_MODE_USES_REJECT]], [[
	size_t new_size = 0;
	yy_state_type *new_state_buf = 0;
]] )

	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(new_buffer);
	 */
	yyensure_buffer_stack (yyscanner);
	if ( yy_current_buffer(yyscanner) == new_buffer ) {
		return;
	}
	if ( yy_current_buffer(yyscanner) ) {
		/* Flush out information for old buffer. */
		*yyscanner->yy_c_buf_p = yyscanner->yy_hold_char;
		yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_buf_pos = yyscanner->yy_c_buf_p;
		yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_n_chars = yyscanner->yy_n_chars;
	}

	yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top] = new_buffer;
	yy_load_buffer_state( yyscanner );

m4_ifdef( [[M4_MODE_USES_REJECT]], [[
	/* Ensure the reject state buffer is large enough.
	 */
	if ( yyscanner->yy_state_buf_max < (yy_current_buffer(yyscanner)->yy_buf_size + YY_STATE_BUF_EXTRA_SPACE) ) {
		new_size = yy_current_buffer(yyscanner)->yy_buf_size + YY_STATE_BUF_EXTRA_SPACE;
		new_state_buf = (yy_state_type *)yyrealloc( yyscanner->yy_state_buf, (new_size * sizeof(yy_state_type)), yyscanner );

		if ( new_state_buf == NULL ) {
			yypanic( "out of dynamic memory in yylex()", yyscanner );
		}
		else {
			yyscanner->yy_state_buf = new_state_buf;
			yyscanner->yy_state_buf_max = new_size;
		}
	}
]] )

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	yyscanner->yy_did_buffer_switch_on_eof = true;
}


m4_ifdef( [[M4_YY_NO_SCAN_BUFFER]],,
[[
/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
yybuffer yy_scan_buffer(char * base, size_t  size, yyscan_t yyscanner)
{
	yybuffer b;

	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR ) {
		/* They forgot to leave room for the EOB's. */
		return NULL;
	}
	b = (yybuffer) yyalloc( sizeof( struct yy_buffer_state ), yyscanner );
	if ( b == NULL ) {
		yypanic( "out of dynamic memory in yy_scan_buffer()", yyscanner );
	}
	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = false;
	b->yy_input_file = NULL;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = false;
	b->yyatbol_flag = true;
	b->yy_fill_buffer = false;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer( b, yyscanner );

	return b;
}
]])

m4_ifdef( [[M4_YY_NO_SCAN_BYTES]],,
[[
/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
yybuffer yy_scan_bytes(const char * yybytes, int  _yybytes_len, yyscan_t yyscanner) {
	yybuffer b;
	char *buf;
	size_t n;
	int i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (size_t) (_yybytes_len + 2);
	buf = (char *) yyalloc( n, yyscanner );
	if ( buf == 0 ) {
		yypanic( "out of dynamic memory in yy_scan_bytes()", yyscanner );
	}
	for ( i = 0; i < _yybytes_len; ++i ) {
		buf[i] = yybytes[i];
	}
	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer( buf, n, yyscanner);
	if ( b == NULL ) {
		yypanic( "bad buffer in yy_scan_bytes()", yyscanner );
	}
	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = true;

	return b;
}
]])

m4_ifdef( [[M4_YY_NO_SCAN_STRING]],,
[[
/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
yybuffer yy_scan_string(const char * yystr, yyscan_t yyscanner)
{
	return yy_scan_bytes( yystr, (int) strlen(yystr), yyscanner);
}
]])

m4_ifdef( [[M4_YY_NO_PUSH_STATE]],,
[[
static void yy_push_state(int _new_state, yyscan_t yyscanner)
{
	if ( yyscanner->yy_start_stack_ptr >= yyscanner->yy_start_stack_depth ) {
		size_t new_size;

		yyscanner->yy_start_stack_depth += YY_START_STACK_INCR;
		new_size = (size_t) yyscanner->yy_start_stack_depth * sizeof( int );

		if ( yyscanner->yy_start_stack == NULL ) {
			yyscanner->yy_start_stack = (int *) yyalloc( new_size, yyscanner );

		} else {
			yyscanner->yy_start_stack = (int *) yyrealloc(
					(void *) yyscanner->yy_start_stack, new_size, yyscanner );
		}
		if ( yyscanner->yy_start_stack == NULL ) {
			yypanic( "out of memory expanding start-condition stack", yyscanner);
		}
	}
	yyscanner->yy_start_stack[yyscanner->yy_start_stack_ptr++] = yystart(yyscanner);

	yybegin(_new_state, yyscanner);
}
]])


m4_ifdef( [[M4_YY_NO_POP_STATE]],,
[[
static void yy_pop_state  (yyscan_t yyscanner)
{
	if ( --yyscanner->yy_start_stack_ptr < 0 ) {
		yypanic( "start-condition stack underflow", yyscanner );
	}
	yybegin(yyscanner->yy_start_stack[yyscanner->yy_start_stack_ptr], yyscanner);
}
]])


m4_ifdef( [[M4_YY_NO_TOP_STATE]],,
[[
static int yy_top_state  (yyscan_t yyscanner)
{
	return yyscanner->yy_start_stack_ptr > 0 ? yyscanner->yy_start_stack[yyscanner->yy_start_stack_ptr - 1] : yystart(yyscanner);
}
]])

%# Code snippets used in various cases of code generation in the main scanner.

m4_define([[M4_GEN_BACKING_UP]], [[
m4_ifdef([[M4_MODE_NO_USES_REJECT]], [[
m4_ifdef([[M4_MODE_HAS_BACKING_UP]], [[
		/* Generate code to keep backing-up information. */
m4_ifdef([[M4_MODE_FULLSPD]], [[
		 if ( yy_current_state[-1].yy_nxt ) {
]])
m4_ifdef([[M4_MODE_NO_FULLSPD]], [[
		if ( yy_accept[yy_current_state] ) {
]])
			yyscanner->yy_last_accepting_state = yy_current_state;
			yyscanner->yy_last_accepting_cpos = yy_cp;
		}
]])
]])
]])

%# yy_c was formerly YY_CHAR, changed to int because table can now
%# have up to 0x101 entries, since we no longer generate a separate
%# NUL table.
%#
%# Note: on x86-64 architecture with gcc -O2, we save an instruction
%# in the main loop, since the character can now be zero-extended in
%# the process of retrieving it from the input stream or the yy_ec[]
%# or yy_meta[] arrays, whereas previously it was zero-extended by a
%# register-to-register move just prior to the yy_chk[] table lookup
m4_define([[M4_GEN_NEXT_COMPRESSED_STATE]], [[
	int yy_c = $1;
	/* Save the backing-up info \before/ computing the next state
	 * because we always compute one more state than needed - we
	 * always proceed until we reach a jam state
	 */
	M4_GEN_BACKING_UP

	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state ) {
		yy_current_state = (int) yy_def[yy_current_state];

m4_ifdef([[M4_MODE_USEMECS]], [[
		/* We've arranged it so that templates are never chained
		 * to one another.  This means we can afford to make a
		 * very simple test to see if we need to convert to
		 * yy_c's meta-equivalence class without worrying
		 * about erroneously looking up the meta-equivalence
		 * class twice
		 */

		/* lastdfa + 2 == YY_JAMSTATE + 1 is the beginning of the templates */
		if (yy_current_state >= YY_JAMSTATE + 1) {
			yy_c = yy_meta[yy_c];
		}
]])
	}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
]])

m4_define([[M4_GEN_START_STATE]], [[
	/* Generate the code to find the start state. */
m4_ifdef([[M4_MODE_FULLSPD]], [[
m4_ifdef([[M4_MODE_BOL_NEEDED]], [[yy_current_state = yy_start_state_list[yyscanner->yy_start + yyatbol()];]])
m4_ifdef([[M4_MODE_NO_BOL_NEEDED]], [[yy_current_state = yy_start_state_list[yyscanner->yy_start];]])
]])
m4_ifdef([[M4_MODE_NO_FULLSPD]], [[
			yy_current_state = yyscanner->yy_start;
m4_ifdef([[M4_MODE_BOL_NEEDED]], [[yy_current_state += yyatbol(yyscanner);]])
			/* Set up for storing up states. */
			m4_ifdef( [[M4_MODE_USES_REJECT]], [[
			yyscanner->yy_state_ptr = yyscanner->yy_state_buf;
			*yyscanner->yy_state_ptr++ = yy_current_state;
]])
]])
]])

m4_define([[M4_GEN_NEXT_MATCH_FULLSPD]], [[
		{
			const struct yy_trans_info *yy_trans_info;
			YY_CHAR yy_c;

			for ( yy_c = $1;
			      (yy_trans_info = &yy_current_state[yy_c])->yy_verify == yy_c;
			      yy_c = $2 )
			{
				yy_current_state += yy_trans_info->yy_nxt;

				M4_GEN_BACKING_UP
			}
		}
]])

/*
 * Helpers for yylex()
 */

%# Conditional indirection through an equivalence map
m4_ifdef([[M4_MODE_USEECS]], m4_define([[M4_EC]], [[*(yy_ec+$1)]]))
m4_ifdef([[M4_MODE_NO_USEECS]], [[m4_define([[M4_EC]], [[$1]])]])

/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state (yyscan_t yyscanner) {
	yy_state_type yy_current_state;
	char *yy_cp;

	M4_GEN_START_STATE
	for ( yy_cp = yyscanner->yytext_ptr + YY_MORE_ADJ; yy_cp < yyscanner->yy_c_buf_p; ++yy_cp ) {
		/* Generate the code to find the next state. */
		m4_ifdef([[M4_MODE_NO_NULTRANS]], [[m4_define([[CHAR_MAP_3]], [[(*yy_cp ? M4_EC(YY_SC_TO_UI(*yy_cp)) : YY_NUL_EC)]])]])
		m4_ifdef([[M4_MODE_NULTRANS]], [[m4_define([[CHAR_MAP_3]], [[M4_EC(YY_SC_TO_UI(*yy_cp))]])]])

		m4_ifdef([[M4_MODE_NULTRANS]], [[
			/* Compressed tables back up *before* they match. */
			m4_ifdef([[M4_MODE_NO_FULLSPD_OR_FULLTBL]], [[M4_GEN_BACKING_UP]])
			if ( *yy_cp ) {
		]])

		m4_ifdef([[M4_MODE_FIND_ACTION_FULLTBL]], [[
			m4_ifdef([[M4_MODE_GENTABLES]], [[yy_current_state = yy_nxt[yy_current_state][CHAR_MAP_3];]])
			m4_ifdef([[M4_MODE_NO_GENTABLES]], [[yy_current_state = yy_nxt[yy_current_state*YY_NXT_LOLEN + CHAR_MAP_3];]])
		]])

		m4_ifdef([[M4_MODE_FULLSPD]], [[yy_current_state += yy_current_state[CHAR_MAP_3].yy_nxt;]])
		m4_ifdef([[M4_MODE_NO_FULLSPD_OR_FULLTBL]], [[M4_GEN_NEXT_COMPRESSED_STATE(CHAR_MAP_3)]])

m4_ifdef([[M4_MODE_NULTRANS]], [[
		} else {
			yy_current_state = yy_NUL_trans[yy_current_state];
		}
]])

		m4_ifdef([[M4_MODE_FIND_ACTION_FULLTBL]], [[M4_GEN_BACKING_UP]])
		m4_ifdef([[M4_MODE_FULLSPD]], [[M4_GEN_BACKING_UP]])
		m4_ifdef([[M4_MODE_USES_REJECT]], [[*yyscanner->yy_state_ptr++ = yy_current_state;]])
	}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state, yyscan_t yyscanner)
{
	bool yy_is_jam;
	/* Generate code for handling NUL's, if needed. */

	/* First, deal with backing up and setting up yy_cp if the scanner
	 * finds that it should JAM on the NUL.
	 *
	 * Only generate a definition for "yy_cp" if we'll generate code
	 * that uses it.  Otherwise lint and the like complain.
	 */
	m4_ifdef([[M4_MODE_NEED_YY_CP]], [[char *yy_cp = yyscanner->yy_c_buf_p;]])

%# Note that this statement block and the following three are
%# not executed serially but are an if-then-else cascade
%# for different table modes.
m4_ifdef([[M4_MODE_NULTRANS]], [[
	yy_current_state = yy_NUL_trans[yy_current_state];
       	yy_is_jam = (yy_current_state == 0);
]])

m4_ifdef([[M4_MODE_NO_NULTRANS]], [[
m4_ifdef([[M4_MODE_NULTRANS_FULLTBL]], [[
m4_ifdef([[M4_MODE_GENTABLES]], [[yy_current_state = yy_nxt[yy_current_state][YY_NUL_EC];]])
m4_ifdef([[M4_MODE_NO_GENTABLES]], [[yy_current_state = yy_nxt[yy_current_state*YY_NXT_LOLEN + YY_NUL_EC];]])
	yy_is_jam = (yy_current_state <= 0);
]])

m4_ifdef([[M4_MODE_NO_NULTRANS_FULLTBL]], [[
m4_ifdef([[M4_MODE_NULTRANS_FULLSPD]], [[
	int yy_c = YY_NUL_EC;

	const struct yy_trans_info *yy_trans_info;

	yy_trans_info = &yy_current_state[(unsigned int) yy_c];
	yy_current_state += yy_trans_info->yy_nxt;
	yy_is_jam = (yy_trans_info->yy_verify != yy_c);
]])

m4_ifdef([[M4_MODE_NO_NULTRANS_FULLSPD]], [[
M4_GEN_NEXT_COMPRESSED_STATE(YY_NUL_EC)
yy_is_jam = (yy_current_state == YY_JAMSTATE);
m4_ifdef([[M4_MODE_USES_REJECT]], [[
	/* Only stack this state if it's a transition we
	 * actually make.  If we stack it on a jam, then
	 * the state stack and yy_c_buf_p get out of sync.
	 */
	if ( ! yy_is_jam ) {
		*yyscanner->yy_state_ptr++ = yy_current_state;
	}
	]])
]])
]])
]])
%# End of if-else cascade

m4_ifdef([[M4_MODE_NULTRANS_WRAP]], [[
	/* If we've entered an accepting state, back up; note that
	 * compressed tables have *already* done such backing up, so
	 * we needn't bother with it again.
	 */
	if ( ! yy_is_jam ) {
		M4_GEN_BACKING_UP
	}
]])

	(void)yyscanner; /* forestall unused-argument warning */
	return yy_is_jam ? 0 : yy_current_state;
}

/** The main scanner function which does all the work.
 */
YY_DECL {
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;

m4_ifdef( [[M4_YY_BISON_LVAL]],
[[
	yylval = yylval_param;
]])

m4_ifdef( [[<M4_YY_BISON_LLOC>]],
[[
	yylloc = yylloc_param;
]])

	if ( !yyscanner->yy_init ) {
		yyscanner->yy_init = true;

		m4_ifdef([[YY_USER_INIT]], [[YY_USER_INIT]])

		if ( yyscanner->yy_start == 0 ) {
			yyscanner->yy_start = 1;	/* first start state */
		}
		if ( yyscanner->yyin_r == NULL ) {
			yyscanner->yyin_r = stdin;
		}
		if ( yyscanner->yyout_r == NULL ) {
			yyscanner->yyout_r = stdout;
		}
		if ( yy_current_buffer(yyscanner) == NULL ) {
			yyensure_buffer_stack (yyscanner);
			yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top] =
				yy_create_buffer( yyscanner->yyin_r, YY_BUF_SIZE, yyscanner);
		}

m4_ifdef( [[M4_MODE_USES_REJECT]],
[[
		/* Create the reject buffer large enough to save one state per allowed character.
		 * If the reject buffer already exists, keep using it.
		 */
		if ( yyscanner->yy_state_buf  == NULL ) {
			yyscanner->yy_state_buf = (yy_state_type *)yyalloc(((yy_current_buffer(yyscanner)->yy_buf_size + YY_STATE_BUF_EXTRA_SPACE) * sizeof(yy_state_type)), yyscanner);
			if ( yyscanner->yy_state_buf == NULL ) {
				yypanic( "out of dynamic memory in yylex()", yyscanner );
			}
			yyscanner->yy_state_buf_max = (yy_current_buffer(yyscanner)->yy_buf_size + YY_STATE_BUF_EXTRA_SPACE);
		}
]])

		yy_load_buffer_state( yyscanner );
	}

	/* open scope of user declarations */
	{
%% [4.0] user's declarations go here

		while ( /*CONSTCOND*/1 ) {		/* loops until end-of-file is reached */
m4_ifdef( [[M4_MODE_YYMORE_USED]], [[
m4_ifdef( [[M4_MODE_NO_YYTEXT_IS_ARRAY]], [[
			yyscanner->yy_more_len = 0;
			if ( yyscanner->yy_more_flag ) {
				yyscanner->yy_more_len = (int) (yyscanner->yy_c_buf_p - yyscanner->yytext_ptr);
				yyscanner->yy_more_flag = false;
			}
]])
]])
			yy_cp = yyscanner->yy_c_buf_p;

			/* Support of yytext. */
			*yy_cp = yyscanner->yy_hold_char;

			/* yy_bp points to the position in yy_ch_buf of the start of
			 * the current run.
			 */
			yy_bp = yy_cp;

M4_GEN_START_STATE

	yy_match:
			/* Generate the code to find the next match. */
m4_ifdef([[M4_MODE_FIND_ACTION_FULLTBL]], [[m4_dnl
m4_ifdef([[M4_MODE_GENTABLES]], [[m4_dnl
			while ((yy_current_state = yy_nxt[yy_current_state][ M4_EC(YY_SC_TO_UI(*yy_cp)) ]) > 0) {
]])
m4_ifdef([[M4_MODE_NO_GENTABLES]], [[
			while ((yy_current_state = yy_nxt[yy_current_state*YY_NXT_LOLEN + M4_EC(YY_SC_TO_UI(*yy_cp)) ]) > 0) {
]])
M4_GEN_BACKING_UP
				yy_cp++;
			}
			yy_current_state = -yy_current_state;
]])
m4_ifdef([[M4_MODE_FULLSPD]], [[
			M4_GEN_NEXT_MATCH_FULLSPD(M4_EC(YY_SC_TO_UI(*yy_cp)), M4_EC(YY_SC_TO_UI(*++yy_cp)))
]])
m4_ifdef([[M4_MODE_NO_FULLSPD_OR_FULLTBL]], [[
			do {
				M4_GEN_NEXT_COMPRESSED_STATE(M4_EC(YY_SC_TO_UI(*yy_cp)))

				m4_ifdef([[M4_MODE_USES_REJECT]], [[*yyscanner->yy_state_ptr++ = yy_current_state;]])
				++yy_cp;

			}
			m4_ifdef([[M4_MODE_INTERACTIVE]], [[while ( yy_base[yy_current_state] != YY_JAMBASE );]])
			m4_ifdef([[M4_MODE_NO_INTERACTIVE]], [[while ( yy_current_state != YY_JAMSTATE );]])

m4_ifdef([[M4_MODE_NO_USES_REJECT]], [[
m4_ifdef([[M4_MODE_NO_INTERACTIVE]], [[
			/* Do the guaranteed-needed backing up to figure out
			 * the match.
			 */
			yy_cp = yyscanner->yy_last_accepting_cpos;
			yy_current_state = yyscanner->yy_last_accepting_state;
]])
]])
]])

	yy_find_action:
			/* code to find the action number goes here */
			m4_ifdef([[M4_MODE_FULLSPD]], [[yy_act = yy_current_state[-1].yy_nxt;]])
			m4_ifdef([[M4_MODE_FIND_ACTION_FULLTBL]], [[yy_act = yy_accept[yy_current_state];]])
m4_ifdef([[M4_MODE_FIND_ACTION_REJECT]], [[
			yy_current_state = *--yyscanner->yy_state_ptr;
			yyscanner->yy_lp = yy_accept[yy_current_state];
m4_ifdef([[M4_MODE_FIND_ACTION_REJECT_REALLY_USED]], [[find_rule: /* we branch to this label when backing up */]])
			for ( ; ; ) {	/* loop until we find out what rule we matched */
				if (yyscanner->yy_lp && yyscanner->yy_lp < yy_accept[yy_current_state + 1]) {
					yy_act = yy_acclist[yyscanner->yy_lp];
m4_ifdef([[M4_MODE_VARIABLE_TRAILING_CONTEXT_RULES]], [[
					if ((yy_act & YY_TRAILING_HEAD_MASK) != 0 || yyscanner->yy_looking_for_trail_begin) {
						if (yy_act == yyscanner->yy_looking_for_trail_begin) {
							yyscanner->yy_looking_for_trail_begin = 0;
							yy_act &= ~YY_TRAILING_HEAD_MASK;
							break;
						}
					} else if (( yy_act & YY_TRAILING_MASK) != 0) {
						yyscanner->yy_looking_for_trail_begin = yy_act & ~YY_TRAILING_MASK;
						yyscanner->yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;
m4_ifdef([[M4_MODE_REAL_REJECT]], [[
						/* Remember matched text in case we back up
						 * due to REJECT.
						 */
						yyscanner->yy_full_match = yy_cp;
						yyscanner->yy_full_state = yyscanner->yy_state_ptr;
						yyscanner->yy_full_lp = yyscanner->yy_lp;
]])
					} else {
						yyscanner->yy_full_match = yy_cp;
						yyscanner->yy_full_state = yyscanner->yy_state_ptr;
						yyscanner->yy_full_lp = yyscanner->yy_lp;
						break;
					}
					++yyscanner->yy_lp;
				goto find_rule;
]])
m4_ifdef([[M4_MODE_NO_VARIABLE_TRAILING_CONTEXT_RULES]], [[
					/* Remember matched text in case we back up due to
					 * trailing context plus REJECT.
					 */
					yyscanner->yy_full_match = yy_cp;
					break;
]])
				}

				--yy_cp;

				/* We could consolidate the following two lines with those at
				 * the beginning, but at the cost of complaints that we're
				 * branching inside a loop.
				 */
				yy_current_state = *--yyscanner->yy_state_ptr;
				yyscanner->yy_lp = yy_accept[yy_current_state];
			} /* close for */
]])
m4_ifdef([[M4_MODE_FIND_ACTION_COMPRESSED]], [[		yy_act = yy_accept[yy_current_state];
			if ( yy_act == 0 ) { /* have to back up */
				yy_cp = yyscanner->yy_last_accepting_cpos;
				yy_current_state = yyscanner->yy_last_accepting_state;
				yy_act = yy_accept[yy_current_state];
			}
]])

			yy_do_before_action(yyscanner, yy_cp, yy_bp);

m4_ifdef( [[M4_MODE_YYLINENO]],[[
m4_define([[M4_YYL_BASE]], [[m4_ifdef([[M4_MODE_YYMORE_USED]],
			    [[m4_ifdef([[M4_MODE_YYTEXT_IS_ARRAY]],
				       [[yyscanner->yy_prev_more_offset]], [[yyscanner->yy_more_len]])]], [[0]])]])
			if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] ) {
				int yyl;
				for ( yyl = M4_YYL_BASE; yyl < yyscanner->yyleng_r; ++yyl ) {
					if ( yyscanner->yytext_r[yyl] == '\n' ) {
						yybumpline( yyscanner );

					}
				}
			}
]])

		do_action:	/* This label is used only to access EOF actions. */

m4_ifdef([[M4_MODE_DEBUG]], [[
			if ( yyscanner->yyflexdebug_r ) {
				if ( yy_act == 0 ) {
					fprintf( stderr, "--scanner backing up\n" );
				} else if ( yy_act < YY_NUM_RULES ) {
					fprintf( stderr, "--accepting rule at line %ld (\"%s\")\n",
						(long)yy_rule_linenum[yy_act], yyscanner->yytext_r );
				} else if ( yy_act == YY_NUM_RULES ) {
					fprintf( stderr, "--accepting default rule (\"%s\")\n",
						 yyscanner->yytext_r );
     				} else if ( yy_act == YY_NUM_RULES + 1 ) {
					fprintf( stderr, "--(end of buffer or a NUL)\n" );
				} else {
					fprintf( stderr, "--EOF (start condition %d)\n", yystart(yyscanner) );
				}
			}
]])

			switch ( yy_act ) { /* beginning of action switch */
m4_ifdef([[M4_MODE_NO_USES_REJECT]], [[
m4_ifdef([[M4_MODE_HAS_BACKING_UP]], [[
			case 0: /* must back up */
				/* undo the effects of yy_do_before_action() */
				*yy_cp = yyscanner->yy_hold_char;

				/* Backing-up info for compressed tables is taken \after/ */
				/* yy_cp has been incremented for the next state. */
				yy_cp = yyscanner->yy_last_accepting_cpos;
				m4_ifdef([[M4_MODE_FULLSPD]], [[yy_cp++;]])
				m4_ifdef([[M4_MODE_FIND_ACTION_FULLTBL]], [[yy_cp++;]])

				yy_current_state = yyscanner->yy_last_accepting_state;
				goto yy_find_action;
]])
]])
%% [5.0] user actions get inserted here

			case YY_END_OF_BUFFER:
			{
				/* Amount of text matched not including the EOB char. */
				int yy_amount_of_matched_text = (int) (yy_cp - yyscanner->yytext_ptr) - 1;

				/* Undo the effects of yy_do_before_action(). */
				*yy_cp = yyscanner->yy_hold_char;
				YY_RESTORE_YY_MORE_OFFSET

				if ( yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_buffer_status == YY_BUFFER_NEW ) {
					/* We're scanning a new file or input source.  It's
					 * possible that this happened because the user
					 * just pointed yyin at a new source and called
					 * yylex().  If so, then we have to assure
					 * consistency between yy_current_buffer(yyscanner) and our
					 * globals.  Here is the right place to do so, because
					 * this is the first action (other than possibly a
					 * back-up) that will match for the new input source.
					 */
					yyscanner->yy_n_chars = yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_n_chars;
					yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_input_file = yyscanner->yyin_r;
					yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_buffer_status = YY_BUFFER_NORMAL;
				}

				/* Note that here we test for yy_c_buf_p "<=" to the position
				 * of the first EOB in the buffer, since yy_c_buf_p will
				 * already have been incremented past the NUL character
				 * (since all states make transitions on EOB to the
				 * end-of-buffer state).  Contrast this with the test
				 * in input().
				 */
				if ( yyscanner->yy_c_buf_p <= &yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf[yyscanner->yy_n_chars] ) { /* This was really a NUL. */
					yy_state_type yy_next_state;

					yyscanner->yy_c_buf_p = yyscanner->yytext_ptr + yy_amount_of_matched_text;

					yy_current_state = yy_get_previous_state( yyscanner );

					/* Okay, we're now positioned to make the NUL
					 * transition.  We couldn't have
					 * yy_get_previous_state() go ahead and do it
					 * for us because it doesn't know how to deal
					 * with the possibility of jamming (and we don't
					 * want to build jamming into it because then it
					 * will run more slowly).
					 */

					yy_next_state = yy_try_NUL_trans( yy_current_state, yyscanner);

					yy_bp = yyscanner->yytext_ptr + YY_MORE_ADJ;

					if ( yy_next_state ) {
						/* Consume the NUL. */
						yy_cp = ++yyscanner->yy_c_buf_p;
						yy_current_state = yy_next_state;
						goto yy_match;
					} else {
%# Disguised case statement on table modes
						m4_ifdef([[M4_MODE_FULLSPD]], [[yy_cp = yyscanner->yy_c_buf_p;]])
						m4_ifdef([[M4_MODE_FIND_ACTION_FULLTBL]], [[yy_cp = yyscanner->yy_c_buf_p;]])
m4_ifdef([[M4_MODE_NO_FULLSPD_OR_FULLTBL]], [[
m4_ifdef([[M4_MODE_NO_USES_REJECT]], [[
m4_ifdef([[M4_NOT_MODE_INTERACTIVE]], [[
						/* Do the guaranteed-needed backing up to figure
						 * out the match.
						 */
						yy_cp = yyscanner->yy_last_accepting_cpos;
						yy_current_state = yyscanner->yy_last_accepting_state;
]])
]])
%# Disguised case statement on table modes ends
m4_ifdef([[M4_MODE_FIND_ACTION_REJECT_OR_INTERACTIVE]], [[
						/* Still need to initialize yy_cp, though
						 * yy_current_state was set up by
						 * yy_get_previous_state().
						 */
						yy_cp = yyscanner->yy_c_buf_p;
]])
]])
						goto yy_find_action;
					}
				} else {	/* not a NUL */
					switch ( yy_get_next_buffer( yyscanner ) ) {
					case EOB_ACT_END_OF_FILE:
						yyscanner->yy_did_buffer_switch_on_eof = false;

						if ( yywrap( yyscanner ) ) {
							/* Note: because we've taken care in
							 * yy_get_next_buffer() to have set up
							 * yytext, we can now set up
							 * yy_c_buf_p so that if some total
							 * hoser (like flex itself) wants to
							 * call the scanner after we return the
							 * YY_NULL, it'll still work - another
							 * YY_NULL will get returned.
							 */
							yyscanner->yy_c_buf_p = yyscanner->yytext_ptr + YY_MORE_ADJ;

							yy_act = YY_STATE_EOF(yystart(yyscanner));
							goto do_action;
						} else {
							if ( ! yyscanner->yy_did_buffer_switch_on_eof ) {
								yyrestart( yyscanner->yyin_r, yyscanner );
							}
						}
						break;
					case EOB_ACT_CONTINUE_SCAN:
						yyscanner->yy_c_buf_p =
							yyscanner->yytext_ptr + yy_amount_of_matched_text;

						yy_current_state = yy_get_previous_state( yyscanner );

						yy_cp = yyscanner->yy_c_buf_p;
						yy_bp = yyscanner->yytext_ptr + YY_MORE_ADJ;
						goto yy_match;

					case EOB_ACT_LAST_MATCH:
						yyscanner->yy_c_buf_p =
						&yyscanner->yy_buffer_stack[yyscanner->yy_buffer_stack_top]->yy_ch_buf[yyscanner->yy_n_chars];

						yy_current_state = yy_get_previous_state( yyscanner );

						yy_cp = yyscanner->yy_c_buf_p;
						yy_bp = yyscanner->yytext_ptr + YY_MORE_ADJ;
						goto yy_find_action;
					default:
						yypanic("unexpected return value from yy_get_next_buffer()", yyscanner);
					} /* end EOB inner switch */
				} /* end if */
				break;
			} /* case YY_END_OF_BUFFER */
			default:
			    yypanic("fatal flex scanner internal error--no action found", yyscanner);
			} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of yylex */

m4_undefine([[yyless]])

/* Redefine yyless() so it works in section 3 code. */

void yyless(int n, yyscan_t yyscanner) {
	/* Undo effects of setting up yytext. */
	m4_ifdef([[M4_MODE_YYLINENO]], [[yy_less_lineno(n, yyscanner);]])
	yyscanner->yytext_r[yyscanner->yyleng_r] = yyscanner->yy_hold_char;
	yyscanner->yy_c_buf_p = yyscanner->yytext_r + n;
	yyscanner->yy_hold_char = *yyscanner->yy_c_buf_p;
	*yyscanner->yy_c_buf_p = '\0';
	yyscanner->yyleng_r = n;
}

static int yy_init_globals (yyscan_t yyscanner) {
	/*
	 * This function is called from yylex_destroy(), so don't allocate here.
	 */
	yyscanner->yy_buffer_stack = NULL;
	yyscanner->yy_buffer_stack_top = 0;
	yyscanner->yy_buffer_stack_max = 0;
	yyscanner->yy_c_buf_p = NULL;
	yyscanner->yy_init = false;
	yyscanner->yy_start = 0;
	yyscanner->yy_start_stack_ptr = 0;
	yyscanner->yy_start_stack_depth = 0;
	yyscanner->yy_start_stack =  NULL;

m4_ifdef( [[M4_MODE_USES_REJECT]],
[[
	yyscanner->yy_state_buf = 0;
	yyscanner->yy_state_ptr = 0;
	yyscanner->yy_state_buf_max = 0;
	yyscanner->yy_full_match = 0;
	yyscanner->yy_lp = 0;
]])

m4_ifdef( [[M4_MODE_YYTEXT_IS_ARRAY]],
[[
	yyscanner->yytext_ptr = 0;
	yyscanner->yy_more_offset = 0;
	yyscanner->yy_prev_more_offset = 0;
]])

	yyscanner->yyin_r = NULL;
	yyscanner->yyout_r = NULL;

	/* For future reference: Set errno on error, since we are called by
	 * yylex_init()
	 */
	return 0;
}

/* User-visible API */

/* yylex_init is special because it creates the scanner itself, so it is
 * the ONLY reentrant function that doesn't take the scanner as the last argument.
 * That's why we explicitly handle the declaration, instead of using our macros.
 */
int yylex_init(yyscan_t* ptr_yy_globals) {
	if (ptr_yy_globals == NULL) {
		errno = EINVAL;
		return 1;
	}

	*ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );

	if (*ptr_yy_globals == NULL) {
		errno = ENOMEM;
		return 1;
	}

	/* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
	memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));

	return yy_init_globals ( *ptr_yy_globals );
}

m4_ifdef([[M4_MODE_EXTRA_TYPE]], [[m4_dnl
/* yylex_init_extra has the same functionality as yylex_init, but follows the
 * convention of taking the scanner as the last argument. Note however, that
 * this is a *pointer* to a scanner, as it will be allocated by this call (and
 * is the reason, too, why this function also must handle its own declaration).
 * The user defined value in the first argument will be available to yyalloc in
 * the yyextra field.
 */
int yylex_init_extra( M4_MODE_EXTRA_TYPE yy_user_defined, yyscan_t* ptr_yy_globals ) {
	struct yyguts_t dummy_yyguts;

	yyset_extra (yy_user_defined, &dummy_yyguts);

	if (ptr_yy_globals == NULL) {
		errno = EINVAL;
		return 1;
	}

	*ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );

	if (*ptr_yy_globals == NULL) {
		errno = ENOMEM;
		return 1;
	}

	/* By setting to 0xAA, we expose bugs in
	   yy_init_globals. Leave at 0x00 for releases. */
	memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));

	yyset_extra (yy_user_defined, *ptr_yy_globals);

	return yy_init_globals ( *ptr_yy_globals );
}
]])

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy  (yyscan_t yyscanner) {

	/* Pop the buffer stack, destroying each element. */
	while(yy_current_buffer(yyscanner)) {
		yypop_buffer_state(yyscanner);
	}

	/* Destroy the stack itself. */
	yyfree(yyscanner->yy_buffer_stack, yyscanner);
	yyscanner->yy_buffer_stack = NULL;

	/* Destroy the start condition stack. */
        yyfree( yyscanner->yy_start_stack, yyscanner );
        yyscanner->yy_start_stack = NULL;

m4_ifdef( [[M4_MODE_USES_REJECT]],
[[
	yyfree ( yyscanner->yy_state_buf, yyscanner);
	yyscanner->yy_state_buf  = NULL;
]])

	/* Reset the globals. This is important in a non-reentrant scanner so the next time
	 * yylex() is called, initialization will occur. */
	yy_init_globals(yyscanner);

	/* Destroy the main struct (reentrant only). */
	yyfree ( yyscanner, yyscanner );
	yyscanner = NULL;
	return 0;
}

m4_ifdef([[M4_YY_MAIN]], [[
int main () {
	yyscan_t lexer;
	yylex_init(&lexer);
	yylex( lexer );
	yylex_destroy( lexer);
	yylex();

	return 0;
}
]])

%# Local Variables:
%# mode:c
%# c-file-style:"k&r"
%# c-basic-offset:8
%# End:
