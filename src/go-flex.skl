%# -*-C-*- vi: set ft=c:
%#
%# This is a fake Go back end. It clones C99, giving output files
%# a .go extension but generating C code. Its purpose is to verify build and test be
%# before actually trying to generate Go.
%#
%# Differences from C:
%#
%# 1. The prefix property doesn't set a prefix for function and variable names.
%#    Instead it sets the Go package name.
%#
%# 2. The (normally hidden) type of the yyguts_t structure becomes FlexLexer,
%#    as in the pre-existing C++ support.  The obfuscation of this type by
%#    a void* i s removed.
%#
%# 3. Because of where expansion of magic names like yytext is done, the _r suffix
%#    on some public member names is not required to keep them from being clobbered
%#    and has been removed.
%#
%# 4. The following names change:
%#
%#    YY_END_OF_BUFFER_CHAR -> flexBufferSentinel
%#    YY_READ_BUF_SIZE -> flexReadBufferSize
%#    YY_BUF_SIZE -> flexInputBufferSize
%#    YY_NUL -> flexEOF

%#  Macros for preproc stage.
m4preproc_changecom

%# Macros for runtime processing stage.
m4_changecom
m4_changequote
m4_changequote([[, ]])

%# Properties not used in the skeleton - meant to be read by the Flex code
m4_define([[M4_PROPERTY_BACKEND_NAME]], [[Go]])
m4_define([[M4_PROPERTY_SOURCE_SUFFIX]], [[go]])
m4_define([[M4_PROPERTY_TRACE_LINE_REGEXP]], [[^#line ([0-9]+) "(.*)"]])
m4_define([[M4_PROPERTY_TRACE_LINE_TEMPLATE]], [[#line %d "%s"]])
m4_define([[M4_PROPERTY_CONTEXT_ARG]], [[yyscanner]])
m4_define([[M4_PROPERTY_CONTEXT_FORMAT]], [[yyscanner->%s]])
m4_define([[M4_PROPERTY_BUFFERSTACK_CONTEXT_FORMAT]], [[yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->bs_%s]])
m4_define([[M4_PROPERTY_PREFIX]], [main]])

%# Macro hooks used by Flex code generators start here
m4_define([[M4_HOOK_INT32]], [[int32_t]])
m4_define([[M4_HOOK_INT16]], [[int16_t]])
m4_define([[M4_HOOK_COMMENT_OPEN]], [[/*]])
m4_define([[M4_HOOK_COMMENT_CLOSE]], [[*/]])
%# If this is not defined, no trace lines will be generated.
m4_define([[M4_HOOK_TRACE_LINE_FORMAT]], [[#line $1 "$2"
]])
m4_define([[M4_HOOK_TABLE_OPENER]], [[{]])
m4_define([[M4_HOOK_TABLE_CONTINUE]], [[},]])
m4_define([[M4_HOOK_TABLE_CLOSER]], [[};]])
m4_define([[M4_HOOK_RELATIVIZE]], [[$1]])
m4_define([[M4_HOOK_STATE_ENTRY_FORMAT]], [[	&yyTransition[$1],
]])
m4_define([[M4_HOOK_NORMAL_STATE_CASE_ARM]], [[	case $1:]])
m4_define([[M4_HOOK_EOF_STATE_CASE_ARM]], [[	case YY_STATE_EOF($1):]])
m4_define([[M4_HOOK_EOF_STATE_CASE_FALLTHROUGH]], [[		/* FALLTHROUGH */]])
m4_define([[M4_HOOK_EOF_STATE_CASE_TERMINATE]], [[		yyterminate();
]])
m4_define([[M4_HOOK_TAKE_YYTEXT]], [[yyDoBeforeAction(yyscanner, yyCp, yyBp); /* set up yytext */]])
m4_define([[M4_HOOK_RELEASE_YYTEXT]], [[*yyCp = yyscanner->yyHoldChar; /* undo effects of setting up yytext */]])
m4_define([[M4_HOOK_CHAR_REWIND]], [[yyscanner->yyCBufP = yyCp -= $1;]])
m4_define([[M4_HOOK_LINE_REWIND]], [[yyLinenoRewindTo(yyCp, yyCp - $1, yyscanner);]])
m4_define([[M4_HOOK_CHAR_FORWARD]], [[yyscanner->yyCBufP = yyCp = yyBp + $1;]])
m4_define([[M4_HOOK_LINE_FORWARD]], [[yyLinenoRewindTo(yyCp, yyBp + $1, yyscanner);]])
m4_define([[M4_HOOK_CONST_DEFINE_BYTE]], [[const char $1 = $2;
]])
m4_define([[M4_HOOK_CONST_DEFINE_STATE]], [[#define $1 $2
]])
m4_define([[M4_HOOK_CONST_DEFINE_UINT]], [[const uint $1 = $2;
]])
m4_define([[M4_HOOK_CONST_DEFINE_BOOL]], [[const bool $1 = $2;
]])
m4_define([[M4_HOOK_CONST_DEFINE_UNKNOWN]], [[m4_define($1, [[$2]])]])
m4_define([[M4_HOOK_SET_YY_DECL]], [[m4_define([[YY_DECL]], [[$1]])]])
m4_define([[M4_HOOK_SET_OFFSET_TYPE]], [[m4_define([[YY_OFFSET_TYPE]], [[$1]])]])
m4_define([[M4_HOOK_SET_USERINIT]], [[m4_define([[YY_USER_INIT]], [[$1]])]])
m4_define([[M4_HOOK_SET_RULE_SETUP]], [[m4_ifdef([[M4_MODE_BOL_NEEDED]], [[
	rule_check_bol(yyscanner);
]])	m4_ifdef([[YY_USER_ACTION]], YY_USER_ACTION)
]])
m4_define([[M4_HOOK_SET_PREACTION]], [[m4_define([[YY_USER_ACTION]], [[$1]])]])
m4_define([[M4_HOOK_STATE_CASE_BREAK]], [[/*LINTED*/break;]])
m4_define([[M4_HOOK_SET_POSTACTION]], [[m4_define([[M4_HOOK_STATE_CASE_BREAK]], [[$1]])]])
m4_define([[M4_HOOK_FATAL_ERROR]], [[yypanic($1, yyscanner);]])
m4_define([[M4_HOOK_ECHO]], [[yyecho(yyscanner);]])

m4_define([[yyterminate]], m4_ifdef([[M4_MODE_YYTERMINATE]], [[M4_MODE_YYTERMINATE /* $1 */]], [[return flexEOF /* $1 */]]))

%# Return all but the first "n" matched characters back to the input stream.
m4_define([[yyless]], [[
	do {
		/* Undo effects of setting up yytext. */
		int yylessMacroArg = ($1);
		m4_ifdef([[M4_MODE_YYLINENO]], [[yyLessLineno(yylessMacroArg, yyscanner);]])
		*yyCp = yyscanner->yyHoldChar;
		YY_RESTORE_YY_MORE_OFFSET
		yyscanner->yyCBufP = yyCp = yyBp + yylessMacroArg - YY_MORE_ADJ;
		yyDoBeforeAction(yyscanner, yyCp, yyBp); /* set up yytext again */
	} while (0)
]])

%# Can't be a function given the context-arg treatment due to the goto.
m4_define([[M4_HOOK_REJECT]], [[{
				*yyCp = yyscanner->yyHoldChar; /* undo effects of setting up yytext */
				yyCp = yyscanner->yyFullMatch; /* restore poss. backed-over text */
m4_ifdef([[M4_MODE_VARIABLE_TRAILING_CONTEXT_RULES]], [[
				yyscanner->yyLp = yyscanner->yyFullLp; /* restore orig. accepting pos. */
				yyscanner->yyStatePtr = yyscanner->yyFullState; /* restore orig. state */
				yyCurrentState = *yyscanner->yyStatePtr; /* restore curr. state */
]])
				++yyscanner->yyLp;
				goto findRuleLabel;
}
]])

%% [0.0] Make hook macros available to Flex

// package M4_MODE_PREFIX

const int YY_FLEX_MAJOR_VERSION = FLEX_MAJOR_VERSION;
const int YY_FLEX_MINOR_VERSION = FLEX_MINOR_VERSION;
const int YY_FLEX_SUBMINOR_VERSION = FLEX_SUBMINOR_VERSION;

/* STARTS platform-specific and compiler-specific definitions. */

m4_ifdef([[M4_YY_ALWAYS_INTERACTIVE]], ,
[[m4_ifdef([[M4_YY_NEVER_INTERACTIVE]], ,
[[/* Feature test macros. Flex uses functions that require a minimum set of
 * macros defined. As defining some macros may hide function declarations that
 * user code might use, be conservative and respect user's definitions as much
 * as possible. In glibc, feature test macros may not be all set up until one
 * of the libc header (that includes <features.h>) is included. This creates
 * a circular dependency when we check the macros. <assert.h> is the safest
 * header we can include and does not declare too many functions we don't need.
 */
#if !defined(__GNU_LIBRARY__) && defined(__STDC__)
#include <assert.h>
#endif
#if !(defined(_POSIX_C_SOURCE) || defined(_XOPEN_SOURCE) || \
    defined(_POSIX_SOURCE))
# define _POSIX_C_SOURCE 1 /* Required for fileno() */
# define _POSIX_SOURCE 1
#endif]])]])

#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <unistd.h>	/* required for isatty() */

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/*
 * Anywhere other than C this won't be a thing,
 * because strings will have an associated length field.
 */
const int flexBufferSentinel = 0;

/* ENDS platform-specific and compiler-specific definitions. */

/*
 * Amount of stuff to slurp up with each read.
 * We assume the stdio library has already
 * chosen a fit size foe whatever platform
 * we're running on.
 */
const int flexReadBufferSize = BUFSIZ;

/* Size of default input buffer. We want to be able to fit two
 * OS-level reads, but efficiency gains as the buffer size
 * increases fall off after that
 */
const int flexInputBufferSize =  m4_ifdef([[M4_MODE_YY_BUFSIZE]], [[M4_MODE_YY_BUFSIZE]], [[2 * flexReadBufferSize]]);

/* Returned upon end-of-file. */
const int flexEOF = 0;

/* Promotes a possibly negative, possibly signed char to an
 * integer in range [0..255] for use as an array index.
 */
m4_define([[YY_SC_TO_UI]], [[((YY_CHAR)($1))]])

/* Action number for EOF rule of a given start state. */
m4_define([[YY_STATE_EOF]], [[YY_END_OF_BUFFER + $1 + 1]])

/* The state buf must be large enough to hold one state per character in the main buffer,
 * plus the start state, plus the two end-of-buffer byte states.
 */
m4_define([[YY_STATE_BUF_EXTRA_SPACE]], [[3]])
m4_define([[YY_STATE_BUF_SIZE]], [[(flexInputBufferSize + YY_STATE_BUF_EXTRA_SPACE)]])

const bool FLEX_DEBUG = m4_ifdef([[M4_MODE_DEBUG]], [[true]], [[false]]);

typedef uint8_t YY_CHAR;

m4_ifdef([[M4_MODE_FULLSPD]], [[m4_dnl
typedef const struct yy_trans_info *yyStateType;
]], [[
typedef int yyStateType;
]])

%% [1.0] DFA

struct yyTransInfo {
	/* We require that yyVerify and yyNxt must be of the same size int. */
m4_ifdef([[M4_MODE_REAL_FULLSPD]], [[
	YY_OFFSET_TYPE yyVerify;

	/* In cases where its sister yyVerify *is* a "yes, there is
	 * a transition", yyNxt is the offset (in records) to the
	 * next state.  In most cases where there is no transition,
	 * the value of yyNxt is irrelevant.  If yyNxt is the -1th
	 * record of a state, though, then yyNxt is the action number
	 * for that state.
	 */
	 YY_OFFSET_TYPE yyNxt;
]])
m4_ifdef([[M4_MODE_NO_REAL_FULLSPD]], [[
	/* We generate a bogus 'struct yyTransInfo' data type
	 * so we can guarantee that it is always declared in the skel.
	 * This is so we can compile "sizeof(struct yyTransInfo)"
	 * in any scanner.
	 */
	int32_t yyVerify;
	int32_t yyNxt;
]])
};

%% [2.0] payload macros for the for the DFA data tables are inserted here

m4_ifdef([[M4_HOOK_NXT_ROWS]],[[m4_dnl
static const M4_HOOK_NXT_TYPE yyNxt[][M4_HOOK_NXT_ROWS] =
M4_HOOK_NXT_BODY
]])

m4_ifdef([[M4_MODE_YYLINENO]],[[m4_dnl
/* Table of booleans, true if rule could match eol. */
static const M4_HOOK_EOLTABLE_TYPE yyRuleCanMatchEOL[M4_HOOK_EOLTABLE_SIZE] = { 0,
M4_HOOK_EOLTABLE_BODY[[]]m4_dnl
};
]])

m4_ifdef([[M4_HOOK_NEED_ACCEPT]],[[m4_dnl
static const M4_HOOK_ACCEPT_TYPE yyAccept[M4_HOOK_ACCEPT_SIZE] = { 0,
M4_HOOK_ACCEPT_BODY[[]]m4_dnl
};
]])

m4_ifdef([[M4_MODE_USEECS]],[[m4_dnl
/* Character equivalence-class mapping */
static const YY_CHAR yyEC[M4_HOOK_ECSTABLE_SIZE] = { 0,
M4_HOOK_ECSTABLE_BODY[[]]m4_dnl
};
]])

m4_ifdef([[M4_MODE_USEMECS]],[[m4_dnl
/* Character meta-equivalence-class mappings */
static const YY_CHAR yyMeta[M4_HOOK_MECSTABLE_SIZE] = { 0,
M4_HOOK_MECSTABLE_BODY[[]]m4_dnl
};
]])

m4_ifdef([[M4_HOOK_TRANSTABLE_SIZE]],[[m4_dnl
/* The transition table */
static const struct yyTransInfo yyTransition[M4_HOOK_TRANSTABLE_SIZE] = {
M4_HOOK_TRANSTABLE_BODY[[]]m4_dnl
};
]])

m4_ifdef([[M4_HOOK_STARTTABLE_SIZE]],[[m4_dnl
/* Table of pointers to start states. */
static const struct yyTransInfo *yyStartStateList[M4_HOOK_STARTTABLE_SIZE] = {
M4_HOOK_STARTTABLE_BODY[[]]m4_dnl
};
]])

m4_ifdef([[M4_HOOK_ACCLIST_TYPE]],[[m4_dnl
static const M4_HOOK_ACCLIST_TYPE yyAcclist[M4_HOOK_ACCLIST_SIZE] = { 0,
M4_HOOK_ACCLIST_BODY[[]]m4_dnl
};
]])

m4_ifdef([[M4_HOOK_BASE_TYPE]],[[m4_dnl
static const M4_HOOK_BASE_TYPE yyBase[M4_HOOK_BASE_SIZE] = { 0,
M4_HOOK_BASE_BODY[[]]m4_dnl
};
]])

m4_ifdef([[M4_HOOK_DEF_TYPE]],[[m4_dnl
static const M4_HOOK_DEF_TYPE yyDef[M4_HOOK_DEF_SIZE] = { 0,
M4_HOOK_DEF_BODY[[]]m4_dnl
};
]])

m4_ifdef([[M4_HOOK_YYNXT_TYPE]],[[m4_dnl
static const M4_HOOK_YYNXT_TYPE yyNxt[M4_HOOK_YYNXT_SIZE] = { 0,
M4_HOOK_YYNXT_BODY[[]]m4_dnl
};
]])

m4_ifdef([[M4_HOOK_CHK_TYPE]],[[m4_dnl
static const M4_HOOK_CHK_TYPE yyChk[M4_HOOK_CHK_SIZE] = { 0,
M4_HOOK_CHK_BODY[[]]m4_dnl
};
]])

m4_ifdef([[M4_HOOK_NULTRANS_SIZE]],[[m4_dnl
static const yyStateType yyNULtrans[M4_HOOK_NULTRANS_SIZE] = { 0,
M4_HOOK_NULTRANS_BODY[[]]m4_dnl
};
]])

m4_ifdef([[M4_MODE_DEBUG]],[[m4_dnl
/* Rule to line-number mapping */
static const M4_HOOK_DEBUGTABLE_TYPE yy_rule_linenum[M4_HOOK_DEBUGTABLE_SIZE] = { 0,
M4_HOOK_DEBUGTABLE_BODY[[]]m4_dnl
};
]])

%% [3.0] static declarations conditional on mode switches go here

M4_YY_SC_DEFS

typedef struct yy_buffer_state *yybuffer;

%# These are not part of the exported interface and can safely be renamed.
/* These must be #defines, not const variables, because they're used as case
 * arm values. GCC will allow case arm expressions to include references to
 * const variables, but this is not standard-conformant and other compilers
 * may not.
 */
#define EOB_ACT_CONTINUE_SCAN	0
#define EOB_ACT_END_OF_FILE	1
#define EOB_ACT_LAST_MATCH	2
#define YY_BUFFER_NEW		0
#define YY_BUFFER_NORMAL	1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING	2

struct yy_buffer_state {
	FILE *yyInputFile;
	char *yyChBuf;		/* input buffer */
	char *yyBufPos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	int yyInputBufSize;

	/* Number of characters read into yyChBuf, not including EOB
	 * characters.
	 */
	int yyNChars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	bool yyIsOurBuffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use char-by-char
	 * rather than a buffered read, to make sure we stop fetching input after
	 * each newline.
	 */
	bool yyIsInteractive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	bool yyatbolFlag;

	int bs_yylineno; /**< The line count. */
	int bs_yycolumn; /**< The column count. */

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	bool yyFillBuffer;

	int yyBufferStatus;
};

/* Watch out: yytext_ptr is a variable when yytext is an array,
 * but it's a macro when yytext is a pointer.
 */
m4_ifdef([[M4_MODE_NO_YYTEXT_IS_ARRAY]], [[
m4_define([[yytext_ptr]], [[yytext]])
]])

m4_ifdef([[M4_MODE_VARIABLE_TRAILING_CONTEXT_RULES]], [[m4_dnl
%# These must match the values in the file flexdef.h
%# of the flex source code, otherwise havoc will ensue.
const int YY_TRAILING_MASK = 0x2000;
const int YY_TRAILING_HEAD_MASK = 0x4000;
]])
/* Holds the entire state of the reentrant scanner. */
typedef struct yyguts_t {
	/* Public interface */
	FILE *yyin, *yyout;
	int yyleng;
	int yylineno;
	int yyflexdebug;
m4_ifdef([[M4_MODE_YYTEXT_IS_ARRAY]], [[
	char yytext[YYLMAX];
]], [[
	char *yytext;
]])

	/* User-defined. Not touched by flex. */
	m4_ifdef([[M4_MODE_EXTRA_TYPE]], [[M4_MODE_EXTRA_TYPE yyextra;]])

	size_t yyBufferStackTop; /**< index of top of stack. */
	size_t yyBufferStackMax; /**< capacity of stack. */
	yybuffer * yyBufferStack; /**< Stack as an array. */
	char yyHoldChar;
	int yyNChars;
	char *yyCBufP;
	bool yyInit;
	int yyStart;
	bool yyDidBufferSwitchOnEof;
	int yyStartStackOffset;
	int yyStartStackDepth;
	int *yyStartStack;
	yyStateType yyLastAcceptingState;
	char* yyLastAcceptingCharPos;

m4_ifdef([[M4_MODE_USES_REJECT]], [[
	yyStateType *yyStateBuf;
	yyStateType *yyStatePtr;
	size_t yyStateBufMax;
	char *yyFullMatch;
	int yyLp;
m4_ifdef([[M4_MODE_VARIABLE_TRAILING_CONTEXT_RULES]], [[m4_dnl
	/* These are only needed for trailing context rules */
	int yyLookingForTrailBegin;
	int yyFullLp;
	int *yyFullState;
]])
]])
m4_ifdef([[M4_MODE_YYTEXT_IS_ARRAY]], [[
	char *yytext_ptr;
	int yyMoreOffset;
	int yyPrevMoreOffset;
]], [[
	bool yyMoreFlag;
	int yyMoreLen;
]])
} FlexLexer; /* end struct yyguts_t */

m4_ifdef([[M4_YY_NO_FLEX_ALLOC]],,
[[
void *yyalloc(size_t size, FlexLexer *yyscanner) {
	(void)yyscanner; /* forestall unused-argument warning */
	return malloc(size);
}
]])

m4_ifdef([[M4_YY_NO_FLEX_REALLOC]],,
[[
void *yyrealloc(void *ptr, size_t size, FlexLexer *yyscanner) {
	(void)yyscanner; /* forestall unused-argument warning */
	return realloc(ptr, size);
}
]])

m4_ifdef([[M4_YY_NO_FLEX_FREE]],,
[[
void yyfree(void * ptr, FlexLexer *yyscanner) {
	(void)yyscanner; /* forestall unused-argument warning */
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	free((char *) ptr);
}
]])

m4_ifdef([[M4_MODE_NO_YYWRAP]], [[
int yywrap(FlexLexer *yyscanner) {
	return /*CONSTCOND*/1;
}
]])

/* Helpers for special functions, also part of public API */

/* Returns the top of the stack, or NULL. */
yybuffer yy_current_buffer(FlexLexer *yyscanner) {
	  return (yyscanner->yyBufferStack					\
		   ? yyscanner->yyBufferStack[yyscanner->yyBufferStackTop] \
		   : NULL);
}

static void yy_load_buffer_state  (FlexLexer *yyscanner)
{
	yyscanner->yyNChars = yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyNChars;
	yyscanner->yytext_ptr = yyscanner->yyCBufP = yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyBufPos;
	yyscanner->yyin = yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyInputFile;
	yyscanner->yyHoldChar = *yyscanner->yyCBufP;
}

/** Discard all buffered characters. On the next scan, yyread() will be called.
 * @param b the buffer state to be flushed, usually @c yy_current_buffer(yyscanner).
 * @param yyscanner The scanner object.
 */
void yy_flush_buffer(yybuffer b, FlexLexer *yyscanner)
{
	if (b == NULL) {
		return;
	}
	b->yyNChars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yyChBuf[0] = flexBufferSentinel;
	b->yyChBuf[1] = flexBufferSentinel;

	b->yyBufPos = &b->yyChBuf[0];

	b->yyatbolFlag = true;
	b->yyBufferStatus = YY_BUFFER_NEW;

	if (b == yy_current_buffer(yyscanner)) {
		yy_load_buffer_state(yyscanner);
	}
}

void yy_flush_current_buffer(FlexLexer *yyscanner) {
	yy_flush_buffer(yy_current_buffer(yyscanner), yyscanner);
}

const int YY_EXIT_FAILURE = 2;

m4_ifdef([[M4_YY_NO_YYPANIC]],, [[
/* This function has a magic rewrite rule */
static void yynoreturn yypanic(const char* msg, FlexLexer *yyscanner) {
	(void)yyscanner; /* forestall unused-argument warning */
	fprintf(stderr, "%s\n", msg);
	exit(YY_EXIT_FAILURE);
}
]])

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack (FlexLexer *yyscanner)
{
	size_t numToAlloc;

	if (yyscanner->yyBufferStack == NULL) {
		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
		 */
		numToAlloc = 1; /* After all that talk, this was set to 1 anyways... */
		yyscanner->yyBufferStack = (struct yy_buffer_state**)yyalloc
			(numToAlloc * sizeof(struct yy_buffer_state*), yyscanner);
		if (yyscanner->yyBufferStack == NULL) {
			yypanic("out of dynamic memory in yyensure_buffer_stack()", yyscanner);
		}

		memset(yyscanner->yyBufferStack, 0, numToAlloc * sizeof(struct yy_buffer_state*));

		yyscanner->yyBufferStackMax = numToAlloc;
		yyscanner->yyBufferStackTop = 0;
		return;
	}

	if (yyscanner->yyBufferStackTop >= (yyscanner->yyBufferStackMax) - 1) {
		/* Increase the buffer to prepare for a possible push. */
		size_t grow_size = 8 /* arbitrary grow size */;

		numToAlloc = yyscanner->yyBufferStackMax + grow_size;
		yyscanner->yyBufferStack = (struct yy_buffer_state**)yyrealloc
								(yyscanner->yyBufferStack,
								 numToAlloc * sizeof(struct yy_buffer_state*),
								yyscanner);
		if (yyscanner->yyBufferStack == NULL) {
			yypanic("out of dynamic memory in yyensure_buffer_stack()", yyscanner);
		}
		/* zero only the new slots.*/
		memset(yyscanner->yyBufferStack + yyscanner->yyBufferStackMax, 0, grow_size * sizeof(struct yy_buffer_state*));
		yyscanner->yyBufferStackMax = numToAlloc;
	}
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
static void yy_init_buffer(yybuffer  b, FILE * file, FlexLexer *yyscanner)
{
	int oerrno = errno;

	yy_flush_buffer(b, yyscanner);

	b->yyInputFile = file;
	if (b->yyInputFile == NULL) {
	  b->yyFillBuffer = false;
	} else {
	  b->yyFillBuffer = true;
	}

	/* If b is the current buffer, then yy_init_buffer was _probably_
	 * called from yyrestart() or through yy_get_next_buffer.
	 * In that case, we don't want to reset the lineno or column.
	 */
	if (b != yy_current_buffer(yyscanner)) {
		b->bs_yylineno = 1;
		b->bs_yycolumn = 0;
	}

m4_ifdef([[M4_YY_ALWAYS_INTERACTIVE]],
[[
	b->yyIsInteractive = true;
]],
[[
    m4_ifdef([[M4_YY_NEVER_INTERACTIVE]],
    [[
    	b->yyIsInteractive = false;
    ]],
    [[
	b->yyIsInteractive = (file != NULL) && (isatty(fileno(file)) > 0);
    ]])
]])
    	errno = oerrno;
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c flexInputBufferSize.
 * @param yyscanner The scanner object.
 * @return the allocated buffer state.
 */
yybuffer yy_create_buffer(FILE *file, int  size, FlexLexer *yyscanner)
{
	yybuffer b;

	b = (yybuffer) yyalloc(sizeof(struct yy_buffer_state), yyscanner);
	if ( b == NULL) {
		yypanic("out of dynamic memory in yy_create_buffer()", yyscanner);
	}
	b->yyInputBufSize = size;

	/* yyChBuf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yyChBuf = (char *) yyalloc((size_t) (b->yyInputBufSize + 2), yyscanner);
	if (b->yyChBuf == NULL) {
		yypanic("out of dynamic memory in yy_create_buffer()", yyscanner);
	}
	b->yyIsOurBuffer = true;

	yy_init_buffer(b, file, yyscanner);

	return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * @param yyscanner The scanner object.
 */
void yy_delete_buffer(yybuffer b, FlexLexer *yyscanner)
{

	if (b == NULL) {
		return;
	}
	if (b == yy_current_buffer(yyscanner)) {	/* Not sure if we should pop here. */
		yyscanner->yyBufferStack[yyscanner->yyBufferStackTop] = (yybuffer)NULL;
	}
	if (b->yyIsOurBuffer) {
		yyfree((void *) b->yyChBuf, yyscanner);
	}
	yyfree((void *) b, yyscanner);
}


/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  @param yyscanner The scanner object.
 */
void yypush_buffer_state(yybuffer new_buffer, FlexLexer *yyscanner)
{
	if (new_buffer == NULL) {
		return;
	}
	yyensure_buffer_stack(yyscanner);

	/* This block is copied from yy_switch_to_buffer. */
	if (yy_current_buffer(yyscanner) != NULL) {
		/* Flush out information for old buffer. */
		*yyscanner->yyCBufP = yyscanner->yyHoldChar;
		yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyBufPos = yyscanner->yyCBufP;
		yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyNChars = yyscanner->yyNChars;
	}

	/* Only push if top exists. Otherwise, replace top. */
	if (yy_current_buffer(yyscanner)) {
		yyscanner->yyBufferStackTop++;
	}
	yyscanner->yyBufferStack[yyscanner->yyBufferStackTop] = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state(yyscanner);
	yyscanner->yyDidBufferSwitchOnEof = true;
}


/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  @param yyscanner The scanner object.
 */
void yypop_buffer_state (FlexLexer *yyscanner)
{
	if (yy_current_buffer(yyscanner) == NULL) {
		return;
	}
	yy_delete_buffer(yy_current_buffer(yyscanner), yyscanner);
	yyscanner->yyBufferStack[yyscanner->yyBufferStackTop] = NULL;
	if (yyscanner->yyBufferStackTop > 0) {
		--yyscanner->yyBufferStackTop;
	}
	if (yy_current_buffer(yyscanner) != NULL) {
		yy_load_buffer_state(yyscanner);
		yyscanner->yyDidBufferSwitchOnEof = true;
	}
}


/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * @param yyscanner The scanner object.
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyrestart(FILE * input_file, FlexLexer *yyscanner)
{

	size_t newSize = 0;
	yyStateType *newStateBuf = 0;

	if (yy_current_buffer(yyscanner) == NULL) {
		yyensure_buffer_stack (yyscanner);
		yyscanner->yyBufferStack[yyscanner->yyBufferStackTop] =
			yy_create_buffer(yyscanner->yyin, flexInputBufferSize, yyscanner);
	}

	yy_init_buffer(yyscanner->yyBufferStack[yyscanner->yyBufferStackTop], input_file, yyscanner);
	yy_load_buffer_state(yyscanner);

m4_ifdef( [[M4_MODE_USES_REJECT]], [[
	/* Ensure the reject state buffer is large enough.
	 */
	if ( yyscanner->yyStateBufMax < (yy_current_buffer(yyscanner)->yyInputBufSize + YY_STATE_BUF_EXTRA_SPACE) ) {
		newSize = yy_current_buffer(yyscanner)->yyInputBufSize + YY_STATE_BUF_EXTRA_SPACE;
		newStateBuf = (yyStateType *)yyrealloc( yyscanner->yyStateBuf, (newSize * sizeof(yyStateType)), yyscanner );

		if ( newStateBuf == NULL ) {
			yypanic( "out of dynamic memory in yylex()", yyscanner );
		}
		else {
			yyscanner->yyStateBuf = newStateBuf;
			yyscanner->yyStateBufMax = newSize;
		}
	}
]] )

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	yyscanner->yyDidBufferSwitchOnEof = true;
}

static void yybumpline(FlexLexer *yyscanner) {
	yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->bs_yylineno++;
        yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->bs_yycolumn=0;
}

/* START special functions
 *
 * Flex's scanner knows these are special and inserts the yyscanner argument
 * at the end of the argument list.  TODO: support OO languages with a
 * property that causes it to be prepended with a dot instead.
 */

/* Enter a start condition. */
void yybegin(int s, FlexLexer *yyscanner) {
	yyscanner->yyStart = 1 + 2 * (s);
}

/* Translate the current start state into a value that can be later handed
 * to yybegin() to return to the state.
 */
int yystart(FlexLexer *yyscanner) {
	return ((yyscanner->yyStart - 1) / 2);
}

/* This used to be an fputs(), but since the string might contain NULs,
 * we now use fwrite().
 */
void yyecho(FlexLexer *yyscanner) {
	fwrite(yyscanner->yytext, (size_t) yyscanner->yyleng, 1, yyscanner->yyout);
}

m4_ifdef([[M4_YY_NO_YYUNPUT]],, [[
void yyunput(char c, FlexLexer *yyscanner)
{
	char *yyCp;

	yyCp = yyscanner->yyCBufP;

	/* undo effects of setting up yytext */
	*yyCp = yyscanner->yyHoldChar;

	if (yyCp < yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf + 2) {
		/* need to shift things up to make room */
		/* +2 for EOB chars. */
		int numberToMove = yyscanner->yyNChars + 2;
		char *dest = &yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf[
					yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyInputBufSize + 2];
		char *source = &yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf[numberToMove];

		while (source > yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf) {
			*--dest = *--source;
		}
		yyCp += (int) (dest - source);
		yyscanner->yytext_ptr += (int) (dest - source);
		yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyNChars =
			yyscanner->yyNChars = (int) yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyInputBufSize;

		if (yyCp < yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf + 2) {
			yypanic("flex scanner push-back overflow", yyscanner);
		}
	}

	*--yyCp = c;

m4_ifdef([[M4_MODE_YYLINENO]],
[[
	if (c == '\n') {
		yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->bs_yylineno--;
	}
]])

	yyscanner->yyHoldChar = *yyCp;
	yyscanner->yyCBufP = yyCp;
}
]])

m4_ifdef([[M4_MODE_USER_YYREAD]],, [[
/* Gets input and stuffs it into "buf".  Number of characters read, or flexEOF,
 * is returned in "result".
 */
static int yyread(char *buf, size_t maxSize, FlexLexer *yyscanner) {
	int result;
m4_ifdef([[M4_MODE_CPP_USE_READ]], [[
	errno=0;
	while ((result = (int) read(fileno(yyscanner->yyin), buf, (size_t) maxSize)) < 0) {
		if(errno != EINTR) {
			yypanic("input in flex scanner failed", yyscanner);
			break;
		}
		errno=0;
		clearerr(yyscanner->yyin);
	}
]])
m4_ifdef([[M4_MODE_NO_CPP_USE_READ]], [[
	if (yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyIsInteractive) {
		int c = '*';
		int n;
		for (n = 0; n < maxSize &&
			      (c = getc(yyscanner->yyin)) != EOF && c != '\n'; ++n) {
			buf[n] = (char) c;
		}
		if (c == '\n') {
			buf[n++] = (char) c;
		}
		if (c == EOF && ferror(yyscanner->yyin)) {
			yypanic("input in flex scanner failed", yyscanner);
		}
		result = n;
	} else {
		errno=0;
		while ((result = (int) fread(buf, 1, (size_t) maxSize, yyscanner->yyin)) == 0 && ferror(yyscanner->yyin)) {
			if(errno != EINTR) {
				yypanic("input in flex scanner failed", yyscanner);
				break;
			}
			errno=0;
			clearerr(yyscanner->yyin);
		}
	}
]])
	 return result;
}
]])

%# yymore has a magic rewrite rule. It's declared here, rather than with the other
%# magic functions, so yy_get_next_buffer() won't need a forward declaration.
m4_ifdef([[M4_MODE_YYMORE_USED]], [[
m4_ifdef([[M4_MODE_YYTEXT_IS_ARRAY]], [[
void yymore(FlexLexer *yyscanner) {yyscanner->yyMoreOffset = strlen(yyscanner->yytext);}
m4_define([[YY_MORE_ADJ]],  [[0]])
m4_define([[YY_RESTORE_YY_MORE_OFFSET]], [[{
yyscanner->yyMoreOffset = yyscanner->yyPrevMoreOffset;
yyscanner->yyleng -= yyscanner->yyMoreOffset;
}
]])
]])
m4_ifdef([[M4_MODE_NO_YYTEXT_IS_ARRAY]], [[
void yymore(FlexLexer *yyscanner) {yyscanner->yyMoreFlag = true;}
m4_define([[YY_MORE_ADJ]],  [[yyscanner->yyMoreLen]])
m4_define([[YY_RESTORE_YY_MORE_OFFSET]], [[]])
]])
]])

m4_ifdef([[M4_MODE_NO_YYMORE_USED]], [[
m4_define([[YY_MORE_ADJ]],  [[0]])
m4_define([[YY_RESTORE_YY_MORE_OFFSET]], [[]])
]])

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (FlexLexer *yyscanner)
{
	char *dest = yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf;
	char *source = yyscanner->yytext_ptr;
	int numberToMove, i;
	int retVal;

	if (yyscanner->yyCBufP > &yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf[yyscanner->yyNChars + 1]) {
		yypanic("fatal flex scanner internal error--end of buffer missed", yyscanner);
	}
	if (!yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyFillBuffer) {
		/* Don't try to fill the buffer, so this is an EOF. */
		if (yyscanner->yyCBufP - yyscanner->yytext_ptr - YY_MORE_ADJ == 1) {
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
		} else {
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
		}
	}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	numberToMove = (int) (yyscanner->yyCBufP - yyscanner->yytext_ptr - 1);

	for (i = 0; i < numberToMove; ++i) {
		*(dest++) = *(source++);
	}
	if (yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyBufferStatus == YY_BUFFER_EOF_PENDING) {
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyNChars = yyscanner->yyNChars = 0;
	} else {
		int numToRead =
			yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyInputBufSize - numberToMove - 1;

		while (numToRead <= 0) { /* Not enough room in the buffer - grow it. */
m4_ifdef([[M4_MODE_USES_REJECT]],
[[
			yypanic(
				"input buffer overflow, can't enlarge buffer because scanner uses reject", yyscanner);
]],
[[
			/* just a shorter name for the current buffer */
			yybuffer b = yyscanner->yyBufferStack[yyscanner->yyBufferStackTop];

			int yyCBufP_offset =
				(int) (yyscanner->yyCBufP - b->yyChBuf);

			if (b->yyIsOurBuffer) {
				int newSize = b->yyInputBufSize * 2;

				if (newSize <= 0) {
					b->yyInputBufSize += b->yyInputBufSize / 8;
				} else {
					b->yyInputBufSize *= 2;
				}
				b->yyChBuf = (char *)
					/* Include room in for 2 EOB chars. */
					yyrealloc((void *) b->yyChBuf,
							 (size_t) (b->yyInputBufSize + 2), yyscanner);
			} else {
				/* Can't grow it, we don't own it. */
				b->yyChBuf = NULL;
			}
			if (b->yyChBuf == NULL) {
				yypanic("fatal error - scanner input buffer overflow", yyscanner);
			}
			yyscanner->yyCBufP = &b->yyChBuf[yyCBufP_offset];

			numToRead = yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyInputBufSize -
						numberToMove - 1;
]])
		}

		if (numToRead > flexReadBufferSize) {
			numToRead = flexReadBufferSize;
		}
		/* Read in more data. */
		yyscanner->yyNChars = yyread(&yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf[numberToMove], numToRead, yyscanner);

		yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyNChars = yyscanner->yyNChars;
	}

	if (yyscanner->yyNChars == 0) {
		if (numberToMove == YY_MORE_ADJ) {
			retVal = EOB_ACT_END_OF_FILE;
			yyrestart(yyscanner->yyin, yyscanner);
		} else {
			retVal = EOB_ACT_LAST_MATCH;
			yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyBufferStatus =
				YY_BUFFER_EOF_PENDING;
		}
	} else {
		retVal = EOB_ACT_CONTINUE_SCAN;
	}
	if ((yyscanner->yyNChars + numberToMove) > yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyInputBufSize) {
		/* Extend the array by 50%, plus the number we really need. */
		int newSize = yyscanner->yyNChars + numberToMove + (yyscanner->yyNChars >> 1);
		yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf = (char *) yyrealloc(
			(void *) yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf, (size_t) newSize, yyscanner);
		if (yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf == NULL) {
			yypanic("out of dynamic memory in yy_get_next_buffer()", yyscanner);
		}
		/* "- 2" to take care of EOB's */
		yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyInputBufSize = (int) (newSize - 2);
	}

	yyscanner->yyNChars += numberToMove;
	yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf[yyscanner->yyNChars] = flexBufferSentinel;
	yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf[yyscanner->yyNChars + 1] = flexBufferSentinel;

	yyscanner->yytext_ptr = &yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf[0];

	return retVal;
}

int yyinput(FlexLexer *yyscanner)
{
	int c;

	*yyscanner->yyCBufP = yyscanner->yyHoldChar;

	if (*yyscanner->yyCBufP == flexBufferSentinel) {
		/* yyCBufP now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if (yyscanner->yyCBufP < &yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf[yyscanner->yyNChars]) {
			/* This was really a NUL. */
			*yyscanner->yyCBufP = '\0';
		} else {
			/* need more input */
			int offset = (int) (yyscanner->yyCBufP - yyscanner->yytext_ptr);
			++yyscanner->yyCBufP;

			switch (yy_get_next_buffer(yyscanner)) {
			case EOB_ACT_LAST_MATCH:
				/* This happens because yy_g_n_b()
				 * sees that we've accumulated a
				 * token and flags that we need to
				 * try matching the token before
				 * proceeding.  But for input(),
				 * there's no matching to consider.
				 * So convert the EOB_ACT_LAST_MATCH
				 * to EOB_ACT_END_OF_FILE.
				 */

				/* Reset buffer status. */
				yyrestart(yyscanner->yyin, yyscanner);

				/*FALLTHROUGH*/

			case EOB_ACT_END_OF_FILE:
				if (yywrap(yyscanner)) {
					return 0;
				}
				if (! yyscanner->yyDidBufferSwitchOnEof) {
					yyrestart(yyscanner->yyin, yyscanner);
				}
				return yyinput(yyscanner);

			case EOB_ACT_CONTINUE_SCAN:
				yyscanner->yyCBufP = yyscanner->yytext_ptr + offset;
				break;
			}
		}
	}

	c = *(unsigned char *) yyscanner->yyCBufP;	/* cast for 8-bit char's */
	*yyscanner->yyCBufP = '\0';	/* preserve yytext */
	yyscanner->yyHoldChar = *++yyscanner->yyCBufP;

m4_ifdef([[M4_MODE_BOL_NEEDED]], [[
	yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyatbolFlag = (c == '\n');
m4_ifdef([[M4_MODE_YYLINENO]], [[
	if (yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyatbolFlag) {
		yybumpline(yyscanner);
	}
]])
]])
m4_ifdef([[M4_MODE_NO_BOL_NEEDED]], [[
m4_ifdef([[M4_MODE_YYLINENO]], [[
	if (c == '\n') {
		yybumpline(yyscanner);
	}
	]])
]])

	return c;
}

/* ENDS special functions

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

m4_ifdef([[M4_MODE_NO_YYWRAP]],, [[
extern int yywrap (FlexLexer *yyscanner);
]])

m4_ifdef([[M4_YY_STACK_USED]],
[[
    m4_ifdef([[M4_YY_NO_PUSH_STATE]],,
    [[
    static void yy_push_state (int newState, FlexLexer *yyscanner);
    ]])
    m4_ifdef([[M4_YY_NO_POP_STATE]],,
    [[
    static void yy_pop_state (FlexLexer *yyscanner);
    ]])
    m4_ifdef([[M4_YY_NO_TOP_STATE]],,
    [[
    static int yy_top_state (FlexLexer *yyscanner);
    ]])
]],
[[
m4_define([[M4_YY_NO_PUSH_STATE]])
m4_define([[M4_YY_NO_POP_STATE]])
m4_define([[M4_YY_NO_TOP_STATE]])
]])

/* STARTS Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

m4_ifdef([[M4_MODE_EXTRA_TYPE]], [[m4_dnl
m4_ifdef([[M4_YY_NO_GET_EXTRA]],, [[m4_dnl
/** Get the user-defined data for this scanner.
 * @param yyscanner The scanner object.
 */
M4_MODE_EXTRA_TYPE yyget_extra(FlexLexer *yyscanner) {
	return yyscanner->yyextra;
}
]])
]])

m4_ifdef([[M4_YY_NO_GET_LINENO]],,
[[
/** Get the current line number.
 * @param yyscanner The scanner object.
 */
int yyget_lineno(FlexLexer *yyscanner) {
	yybuffer cb = yy_current_buffer(yyscanner);

	if (cb == NULL) {
		return 0;
	}
	return cb->bs_yylineno;
}
]])

m4_ifdef([[M4_YY_NO_GET_COLUMN]],,
[[
/** Get the current column number.
 * @param yyscanner The scanner object.
 */
int yyget_column  (FlexLexer *yyscanner) {
	yybuffer cb = yy_current_buffer(yyscanner);

	if (cb == NULL) {
		return 0;
	}
	return cb->bs_yycolumn;
}
]])

m4_ifdef([[M4_YY_NO_GET_IN]],,
[[
/** Get the input stream.
 * @param yyscanner The scanner object.
 */
FILE *yyget_in  (FlexLexer *yyscanner) {
	return yyscanner->yyin;
}
]])

m4_ifdef([[M4_YY_NO_GET_OUT]],,
[[
/** Get the output stream.
 * @param yyscanner The scanner object.
 */
FILE *yyget_out  (FlexLexer *yyscanner) {
	return yyscanner->yyout;
}
]])

m4_ifdef([[M4_YY_NO_GET_LENG]],,
[[
/** Get the length of the current token.
 * @param yyscanner The scanner object.
 */
int yyget_leng  (FlexLexer *yyscanner) {
	return yyscanner->yyleng;
}
]])

/** Get the current token.
 * @param yyscanner The scanner object.
 */
m4_ifdef([[M4_YY_NO_GET_TEXT]],,
[[
char *yyget_text  (FlexLexer *yyscanner) {
	return yyscanner->yytext;
}
]])

m4_ifdef([[M4_MODE_EXTRA_TYPE]], [[m4_dnl
m4_ifdef([[M4_YY_NO_SET_EXTRA]],,
[[
/** Set the user-defined data. This data is never touched by the scanner.
 * @param userDefined The data to be associated with this scanner.
 * @param yyscanner The scanner object.
 */
void yyset_extra(M4_MODE_EXTRA_TYPE userDefined, FlexLexer *yyscanner) {
	yyscanner->yyextra = userDefined;
}
]])
]])

m4_ifdef([[M4_YY_NO_SET_LINENO]],,
[[
/** Set the current line number.
 * @param lineNumber line number
 * @param yyscanner The scanner object.
 */
void yyset_lineno(int lineNumber, FlexLexer *yyscanner) {
	yybuffer cb = yy_current_buffer(yyscanner);

	/* lineno is only valid if an input buffer exists. */
	if (cb == NULL) {
		yypanic("yyset_lineno called with no buffer", yyscanner);
	}
	cb->bs_yylineno = lineNumber;
}
]])

m4_ifdef([[M4_YY_NO_SET_COLUMN]],,
[[
/** Set the current column.
 * @param columnNo column number
 * @param yyscanner The scanner object.
 */
void yyset_column(int columnNo, FlexLexer *yyscanner) {
	yybuffer cb = yy_current_buffer(yyscanner);

	/* column is only valid if an input buffer exists. */
	if (cb == NULL) {
		yypanic("yyset_column called with no buffer", yyscanner);
	}
	cb->bs_yycolumn = columnNo;
}
]])

m4_ifdef([[M4_YY_NO_SET_IN]],,
[[
/** Set the input stream. This does not discard the current
 * input buffer.
 * @param inStream A readable stream.
 * @param yyscanner The scanner object.
 * @see yy_switch_to_buffer
 */
void yyset_in(FILE *inStream, FlexLexer *yyscanner) {
	yyscanner->yyin = inStream ;
}
]])

m4_ifdef([[M4_YY_NO_SET_OUT]],,
[[
void yyset_out(FILE *outStream, FlexLexer *yyscanner) {
	yyscanner->yyout = outStream ;
}
]])


m4_ifdef([[M4_YY_NO_GET_DEBUG]],,
[[
int yyget_debug(FlexLexer *yyscanner) {
	return yyscanner->yyflexdebug;
}
]])

m4_ifdef([[M4_YY_NO_SET_DEBUG]],,
[[
void yyset_debug(int bdebug, FlexLexer *yyscanner) {
	yyscanner->yyflexdebug = bdebug ;
}
]])

/* ENDS public accessor functions */

/* Number of entries by which start-condition stack grows. */
const int YY_START_STACK_INCR = 25;

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
m4_ifdef([[YY_DECL]],, [[m4_dnl
m4_define([[M4_YY_LEX_PROTO]], [[(FlexLexer *yyscanner)]])
m4_define([[M4_YY_LEX_DECLARATION]], [[(FlexLexer *yyscanner)]])
m4_define([[YY_DECL]], [[int yylex M4_YY_LEX_DECLARATION]])
]])

m4_ifdef([[M4_MODE_BOL_NEEDED]], [[
static void rule_check_bol(FlexLexer *yyscanner) {
	if (yyscanner->yyleng > 0) {		\
		yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyatbolFlag = (yyscanner->yytext[yyscanner->yyleng - 1] == '\n');
	}
}
]])

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.  yyCp and yyBp are the
 * end abd start pointers for the input buffer segment that is
 * claimed as yytext.
 */
void yyDoBeforeAction(FlexLexer *yyscanner, char *yyCp, char *yyBp) {
	yyscanner->yytext_ptr = yyBp; \
	m4_ifdef([[M4_MODE_YYMORE_USED]], [[m4_ifdef([[M4_MODE_NO_YYTEXT_IS_ARRAY]], [[yyscanner->yytext_ptr -= yyscanner->yyMoreLen; \
	yyscanner->yyleng = (int) (yyCp - yyscanner->yytext_ptr);]])]]) \
	m4_ifdef([[M4_MODE_NO_YYMORE_USED]], [[yyscanner->yyleng = (int) (yyCp - yyBp);]]) \
	m4_ifdef([[M4_MODE_YYTEXT_IS_ARRAY]], [[yyscanner->yyleng = (int) (yyCp - yyBp);]]) \
	yyscanner->yyHoldChar = *yyCp; \
	*yyCp = '\0'; \
m4_ifdef([[M4_MODE_YYTEXT_IS_ARRAY]], [[ \
	m4_ifdef([[M4_MODE_YYMORE_USED]], [[if (yyscanner->yyleng + yyscanner->yyMoreOffset >= YYLMAX) \
					 yypanic("token too large, exceeds YYLMAX", yyscanner);]]) \
	m4_ifdef([[M4_MODE_NO_YYMORE_USED]], [[if (yyscanner->yyleng >= YYLMAX) \
					 yypanic("token too large, exceeds YYLMAX", yyscanner);]]) \
	m4_ifdef([[M4_MODE_YYMORE_USED]], [[strncpy(&yyscanner->yytext[yyscanner->yyMoreOffset], yyscanner->yytext_ptr, yyscanner->yyleng + 1);]]) \
	m4_ifdef([[M4_MODE_YYMORE_USED]], [[yyscanner->yyleng += yyscanner->yyMoreOffset;]]) \
	m4_ifdef([[M4_MODE_YYMORE_USED]], [[yyscanner->yyPrevMoreOffset = yyscanner->yyMoreOffset;]]) \
	m4_ifdef([[M4_MODE_YYMORE_USED]], [[yyscanner->yyMoreOffset = 0;]]) \
	m4_ifdef([[M4_MODE_NO_YYMORE_USED]], [[strncpy(yyscanner->yytext, yyscanner->yytext_ptr, yyscanner->yyleng + 1);]]) \
]]) \
	yyscanner->yyCBufP = yyCp;
}

m4_ifdef([[M4_MODE_YYLINENO]], [[
/* FIXME: gate on yyRuleCanMatchEOL, this is no longer a macro
 * and we can get at yyAct */
static void yyLessLineno(int n, FlexLexer *yyscanner) {
	int yyl;
	for (yyl = n; yyl < yyscanner->yyleng; ++yyl) {
		if (yyscanner->yytext[yyl] == '\n') {
			yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->bs_yylineno--;
		}
	}
}

static void yyLinenoRewindTo(char *yyCp, char *dst, FlexLexer *yyscanner)  {
	const char *p;
	for (p = yyCp-1; p >= dst; --p) {
		if (*p == '\n') {
			yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->bs_yylineno--;
		}
	}
}
]])

void yy_set_interactive(bool is_interactive, FlexLexer *yyscanner) {
	if (yy_current_buffer(yyscanner) == NULL) {
		yyensure_buffer_stack (yyscanner);
		yyscanner->yyBufferStack[yyscanner->yyBufferStackTop] =
			yy_create_buffer(yyscanner->yyin, flexInputBufferSize, yyscanner);
	}
	yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyIsInteractive = is_interactive;
}


void yysetbol(bool atBOL, FlexLexer *yyscanner) {
	if (yy_current_buffer(yyscanner) == NULL) {
		yyensure_buffer_stack (yyscanner);
		yyscanner->yyBufferStack[yyscanner->yyBufferStackTop] =
        		yy_create_buffer(yyscanner->yyin, flexInputBufferSize, yyscanner);
	}
	yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyatbolFlag = atBOL;
}

bool yyatbol(FlexLexer *yyscanner) {
	return (yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyatbolFlag);
}

/** Switch to a different input buffer.
 * @param newBuffer The new input buffer.
 * @param yyscanner The scanner object.
 */
void yy_switch_to_buffer(yybuffer newBuffer, FlexLexer *yyscanner)
{
	size_t newSize = 0;
	yyStateType *newStateBuf = 0;

	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(newBuffer);
	 */
	yyensure_buffer_stack (yyscanner);
	if (yy_current_buffer(yyscanner) == newBuffer) {
		return;
	}
	if (yy_current_buffer(yyscanner)) {
		/* Flush out information for old buffer. */
		*yyscanner->yyCBufP = yyscanner->yyHoldChar;
		yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyBufPos = yyscanner->yyCBufP;
		yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyNChars = yyscanner->yyNChars;
	}

	yyscanner->yyBufferStack[yyscanner->yyBufferStackTop] = newBuffer;
	yy_load_buffer_state(yyscanner);

m4_ifdef( [[M4_MODE_USES_REJECT]], [[
	/* Ensure the reject state buffer is large enough.
	 */
	if ( yyscanner->yyStateBufMax < (yy_current_buffer(yyscanner)->yyInputBufSize + YY_STATE_BUF_EXTRA_SPACE) ) {
		newSize = yy_current_buffer(yyscanner)->yyInputBufSize + YY_STATE_BUF_EXTRA_SPACE;
		newStateBuf = (yyStateType *)yyrealloc( yyscanner->yyStateBuf, (newSize * sizeof(yyStateType)), yyscanner );

		if ( newStateBuf == NULL ) {
			yypanic( "out of dynamic memory in yylex()", yyscanner );
		}
		else {
			yyscanner->yyStateBuf = newStateBuf;
			yyscanner->yyStateBufMax = newSize;
		}
	}
]] )

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	yyscanner->yyDidBufferSwitchOnEof = true;
}


m4_ifdef([[M4_YY_NO_SCAN_BUFFER]],,
[[
/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
yybuffer yy_scan_buffer(char *base, size_t size, FlexLexer *yyscanner)
{
	yybuffer b;

	if (size < 2 ||
	     base[size-2] != flexBufferSentinel ||
	     base[size-1] != flexBufferSentinel) {
		/* They forgot to leave room for the EOB's. */
		return NULL;
	}
	b = (yybuffer) yyalloc(sizeof(struct yy_buffer_state), yyscanner);
	if (b == NULL) {
		yypanic("out of dynamic memory in yy_scan_buffer()", yyscanner);
	}
	b->yyInputBufSize = (int) (size - 2);	/* "- 2" to take care of EOB's */
	b->yyBufPos = b->yyChBuf = base;
	b->yyIsOurBuffer = false;
	b->yyInputFile = NULL;
	b->yyNChars = b->yyInputBufSize;
	b->yyIsInteractive = false;
	b->yyatbolFlag = true;
	b->yyFillBuffer = false;
	b->yyBufferStatus = YY_BUFFER_NEW;

	yy_switch_to_buffer(b, yyscanner);

	return b;
}
]])

m4_ifdef([[M4_YY_NO_SCAN_BYTES]],,
[[
/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
yybuffer yy_scan_bytes(const char * yybytes, int  _yybytes_len, FlexLexer *yyscanner) {
	yybuffer b;
	char *buf;
	size_t n;
	int i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (size_t) (_yybytes_len + 2);
	buf = (char *) yyalloc(n, yyscanner);
	if (buf == 0) {
		yypanic("out of dynamic memory in yy_scan_bytes()", yyscanner);
	}
	for (i = 0; i < _yybytes_len; ++i) {
		buf[i] = yybytes[i];
	}
	buf[_yybytes_len] = buf[_yybytes_len+1] = flexBufferSentinel;

	b = yy_scan_buffer(buf, n, yyscanner);
	if (b == NULL) {
		yypanic("bad buffer in yy_scan_bytes()", yyscanner);
	}
	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yyIsOurBuffer = true;

	return b;
}
]])

m4_ifdef([[M4_YY_NO_SCAN_STRING]],,
[[
/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
yybuffer yy_scan_string(const char * yystr, FlexLexer *yyscanner)
{
	return yy_scan_bytes(yystr, (int) strlen(yystr), yyscanner);
}
]])

m4_ifdef([[M4_YY_NO_PUSH_STATE]],,
[[
static void yy_push_state(int newState, FlexLexer *yyscanner)
{
	if (yyscanner->yyStartStackOffset >= yyscanner->yyStartStackDepth) {
		size_t newSize;

		yyscanner->yyStartStackDepth += YY_START_STACK_INCR;
		newSize = (size_t) yyscanner->yyStartStackDepth * sizeof(int);

		if (yyscanner->yyStartStack == NULL) {
			yyscanner->yyStartStack = (int *) yyalloc(newSize, yyscanner);

		} else {
			yyscanner->yyStartStack = (int *) yyrealloc(
					(void *) yyscanner->yyStartStack, newSize, yyscanner);
		}
		if (yyscanner->yyStartStack == NULL) {
			yypanic("out of memory expanding start-condition stack", yyscanner);
		}
	}
	yyscanner->yyStartStack[yyscanner->yyStartStackOffset++] = yystart(yyscanner);

	yybegin(newState, yyscanner);
}
]])


m4_ifdef([[M4_YY_NO_POP_STATE]],,
[[
static void yy_pop_state(FlexLexer *yyscanner)
{
	if (--yyscanner->yyStartStackOffset < 0) {
		yypanic("start-condition stack underflow", yyscanner);
	}
	yybegin(yyscanner->yyStartStack[yyscanner->yyStartStackOffset], yyscanner);
}
]])


m4_ifdef([[M4_YY_NO_TOP_STATE]],,
[[
static int yy_top_state(FlexLexer *yyscanner)
{
	return yyscanner->yyStartStackOffset > 0 ? yyscanner->yyStartStack[yyscanner->yyStartStackOffset - 1] : yystart(yyscanner);
}
]])

%# Code snippets used in various cases of code generation in the main scanner.

m4_define([[M4_GEN_BACKING_UP]], [[
m4_ifdef([[M4_MODE_NO_USES_REJECT]], [[
m4_ifdef([[M4_MODE_HAS_BACKING_UP]], [[
		/* Generate code to keep backing-up information. */
m4_ifdef([[M4_MODE_FULLSPD]], [[
		 if (yyCurrentState[-1].yyNxt) {
]])
m4_ifdef([[M4_MODE_NO_FULLSPD]], [[
		if (yyAccept[yyCurrentState]) {
]])
			yyscanner->yyLastAcceptingState = yyCurrentState;
			yyscanner->yyLastAcceptingCharPos = yyCp;
		}
]])
]])
]])

%# yyChar was formerly YY_CHAR, changed to int because table can now
%# have up to 0x101 entries, since we no longer generate a separate
%# NUL table.
%#
%# Note: on x86-64 architecture with gcc -O2, we save an instruction
%# in the main loop, since the character can now be zero-extended in
%# the process of retrieving it from the input stream or the yyEC[]
%# or yyMeta[] arrays, whereas previously it was zero-extended by a
%# register-to-register move just prior to the yyChk[] table lookup
m4_define([[M4_GEN_NEXT_COMPRESSED_STATE]], [[
	int yyChar = $1;
	/* Save the backing-up info \before/ computing the next state
	 * because we always compute one more state than needed - we
	 * always proceed until we reach a jam state
	 */
	M4_GEN_BACKING_UP

	while (yyChk[yyBase[yyCurrentState] + yyChar] != yyCurrentState) {
		yyCurrentState = (int) yyDef[yyCurrentState];

m4_ifdef([[M4_MODE_USEMECS]], [[
		/* We've arranged it so that templates are never chained
		 * to one another.  This means we can afford to make a
		 * very simple test to see if we need to convert to
		 * yyChar's meta-equivalence class without worrying
		 * about erroneously looking up the meta-equivalence
		 * class twice
		 */

		/* lastdfa + 2 == YY_JAMSTATE + 1 is the beginning of the templates */
		if (yyCurrentState >= YY_JAMSTATE + 1) {
			yyChar = yyMeta[yyChar];
		}
]])
	}
	yyCurrentState = yyNxt[yyBase[yyCurrentState] + yyChar];
]])

m4_define([[M4_GEN_START_STATE]], [[
	/* Generate the code to find the start state. */
m4_ifdef([[M4_MODE_FULLSPD]], [[
m4_ifdef([[M4_MODE_BOL_NEEDED]], [[yyCurrentState = yyStartStateList[yyscanner->yyStart + yyatbol()];]])
m4_ifdef([[M4_MODE_NO_BOL_NEEDED]], [[yyCurrentState = yyStartStateList[yyscanner->yyStart];]])
]])
m4_ifdef([[M4_MODE_NO_FULLSPD]], [[
			yyCurrentState = yyscanner->yyStart;
m4_ifdef([[M4_MODE_BOL_NEEDED]], [[yyCurrentState += yyatbol(yyscanner);]])
			/* Set up for storing up states. */
			m4_ifdef([[M4_MODE_USES_REJECT]], [[
			yyscanner->yyStatePtr = yyscanner->yyStateBuf;
			*yyscanner->yyStatePtr++ = yyCurrentState;
]])
]])
]])

m4_define([[M4_GEN_NEXT_MATCH_FULLSPD]], [[
		{
			const struct yyTransInfo *yyTransInfo;
			YY_CHAR yyChar;

			for (yyChar = $1;
			      (yyTransInfo = &yyCurrentState[yyChar])->yyVerify == yyChar;
			      yyChar = $2)
			{
				yyCurrentState += yyTransInfo->yyNxt;

				M4_GEN_BACKING_UP
			}
		}
]])

/*
 * Helpers for yylex()
 */

%# Conditional indirection through an equivalence map
m4_ifdef([[M4_MODE_USEECS]], m4_define([[M4_EC]], [[*(yyEC+$1)]]))
m4_ifdef([[M4_MODE_NO_USEECS]], [[m4_define([[M4_EC]], [[$1]])]])

/* yyGetPreviousState - get the state just before the EOB char was reached */

static yyStateType yyGetPreviousState(FlexLexer *yyscanner) {
	yyStateType yyCurrentState;
	char *yyCp;

	M4_GEN_START_STATE
	for (yyCp = yyscanner->yytext_ptr + YY_MORE_ADJ; yyCp < yyscanner->yyCBufP; ++yyCp) {
		/* Generate the code to find the next state. */
		m4_ifdef([[M4_MODE_NO_NULTRANS]], [[m4_define([[CHAR_MAP_3]], [[(*yyCp ? M4_EC(YY_SC_TO_UI(*yyCp)) : YY_NUL_EC)]])]])
		m4_ifdef([[M4_MODE_NULTRANS]], [[m4_define([[CHAR_MAP_3]], [[M4_EC(YY_SC_TO_UI(*yyCp))]])]])

		m4_ifdef([[M4_MODE_NULTRANS]], [[
			/* Compressed tables back up *before* they match. */
			m4_ifdef([[M4_MODE_NO_FULLSPD_OR_FULLTBL]], [[M4_GEN_BACKING_UP]])
			if (*yyCp) {
		]])

		m4_ifdef([[M4_MODE_FIND_ACTION_FULLTBL]], [[
			m4_ifdef([[M4_MODE_GENTABLES]], [[yyCurrentState = yyNxt[yyCurrentState][CHAR_MAP_3];]])
			m4_ifdef([[M4_MODE_NO_GENTABLES]], [[yyCurrentState = yyNxt[yyCurrentState*YYNXT_LOLEN + CHAR_MAP_3];]])
		]])

		m4_ifdef([[M4_MODE_FULLSPD]], [[yyCurrentState += yyCurrentState[CHAR_MAP_3].yyNxt;]])
		m4_ifdef([[M4_MODE_NO_FULLSPD_OR_FULLTBL]], [[M4_GEN_NEXT_COMPRESSED_STATE(CHAR_MAP_3)]])

m4_ifdef([[M4_MODE_NULTRANS]], [[
		} else {
			yyCurrentState = yyNULtrans[yyCurrentState];
		}
]])

		m4_ifdef([[M4_MODE_FIND_ACTION_FULLTBL]], [[M4_GEN_BACKING_UP]])
		m4_ifdef([[M4_MODE_FULLSPD]], [[M4_GEN_BACKING_UP]])
		m4_ifdef([[M4_MODE_USES_REJECT]], [[*yyscanner->yyStatePtr++ = yyCurrentState;]])
	}

	return yyCurrentState;
}

/* yyTryNULtrans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yyTryNULtrans(current_state);
 */
static yyStateType yyTryNULtrans(yyStateType yyCurrentState, FlexLexer *yyscanner)
{
	bool yyIsJam;
	/* Generate code for handling NULs, if needed. */

	/* First, deal with backing up and setting up yyCp if the scanner
	 * finds that it should JAM on the NUL.
	 *
	 * Only generate a definition for "yyCp" if we'll generate code
	 * that uses it.  Otherwise validators complain.
	 */
	m4_ifdef([[M4_MODE_NEED_YY_CP]], [[char *yyCp = yyscanner->yyCBufP;]])

%# Note that this statement block and the following three are
%# not executed serially but are an if-then-else cascade
%# for different table modes.
m4_ifdef([[M4_MODE_NULTRANS]], [[
	yyCurrentState = yyNULtrans[yyCurrentState];
       	yyIsJam = (yyCurrentState == 0);
]])

m4_ifdef([[M4_MODE_NO_NULTRANS]], [[
m4_ifdef([[M4_MODE_NULTRANS_FULLTBL]], [[
m4_ifdef([[M4_MODE_GENTABLES]], [[yyCurrentState = yyNxt[yyCurrentState][YY_NUL_EC];]])
m4_ifdef([[M4_MODE_NO_GENTABLES]], [[yyCurrentState = yyNxt[yyCurrentState*YYNXT_LOLEN + YY_NUL_EC];]])
	yyIsJam = (yyCurrentState <= 0);
]])

m4_ifdef([[M4_MODE_NO_NULTRANS_FULLTBL]], [[
m4_ifdef([[M4_MODE_NULTRANS_FULLSPD]], [[
	int yyChar = YY_NUL_EC;

	const struct yyTransInfo *yyTransInfo;

	yyTransInfo = &yyCurrentState[(unsigned int) yyChar];
	yyCurrentState += yyTransInfo->yyNxt;
	yyIsJam = (yyTransInfo->yyVerify != yyChar);
]])

m4_ifdef([[M4_MODE_NO_NULTRANS_FULLSPD]], [[
M4_GEN_NEXT_COMPRESSED_STATE(YY_NUL_EC)
yyIsJam = (yyCurrentState == YY_JAMSTATE);
m4_ifdef([[M4_MODE_USES_REJECT]], [[
	/* Only stack this state if it's a transition we
	 * actually make.  If we stack it on a jam, then
	 * the state stack and yyCBufP get out of sync.
	 */
	if (! yyIsJam) {
		*yyscanner->yyStatePtr++ = yyCurrentState;
	}
	]])
]])
]])
]])
%# End of if-else cascade

m4_ifdef([[M4_MODE_NULTRANS_WRAP]], [[
	/* If we've entered an accepting state, back up; note that
	 * compressed tables have *already* done such backing up, so
	 * we needn't bother with it again.
	 */
	if (!yyIsJam) {
		M4_GEN_BACKING_UP
	}
]])

	(void)yyscanner; /* forestall unused-argument warning */
	return yyIsJam ? 0 : yyCurrentState;
}

/** The main scanner function which does all the work.
 */
YY_DECL {
	yyStateType yyCurrentState;
	char *yyCp, *yyBp;
	int yyAct;

m4_ifdef([[M4_YY_BISON_LVAL]],
[[
	yylval = yylval_param;
]])

m4_ifdef([[<M4_YY_BISON_LLOC>]],
[[
	yylloc = yylloc_param;
]])

	if (!yyscanner->yyInit) {
		yyscanner->yyInit = true;

		m4_ifdef([[YY_USER_INIT]], [[YY_USER_INIT]])

		if (yyscanner->yyStart == 0) {
			yyscanner->yyStart = 1;	/* first start state */
		}
		if (yyscanner->yyin == NULL) {
			yyscanner->yyin = stdin;
		}
		if (yyscanner->yyout == NULL) {
			yyscanner->yyout = stdout;
		}
		if (yy_current_buffer(yyscanner) == NULL) {
			yyensure_buffer_stack (yyscanner);
			yyscanner->yyBufferStack[yyscanner->yyBufferStackTop] =
				yy_create_buffer(yyscanner->yyin, flexInputBufferSize, yyscanner);
		}

m4_ifdef([[M4_MODE_USES_REJECT]],
[[
		/* Create the reject buffer large enough to save one state per allowed character.
		 * If the reject buffer already exists, keep using it.
		 */
		if (yyscanner->yyStateBuf  == NULL) {
			yyscanner->yyStateBuf = (yyStateType *)yyalloc((yy_current_buffer(yyscanner)->yyInputBufSize + YY_STATE_BUF_EXTRA_SPACE) * sizeof(yyStateType), yyscanner);
			if ( yyscanner->yyStateBuf == NULL ) {
				yypanic( "out of dynamic memory in yylex()", yyscanner );
			}
			yyscanner->yyStateBufMax = (yy_current_buffer(yyscanner)->yyInputBufSize + YY_STATE_BUF_EXTRA_SPACE);
		}
]])

		yy_load_buffer_state(yyscanner);
	}

	/* open scope of user declarationns */
	{
%% [4.0] user's declarations go here

		while (/*CONSTCOND*/1) {		/* loops until end-of-file is reached */
m4_ifdef([[M4_MODE_YYMORE_USED]], [[
m4_ifdef([[M4_MODE_NO_YYTEXT_IS_ARRAY]], [[
			yyscanner->yyMoreLen = 0;
			if (yyscanner->yyMoreFlag) {
				yyscanner->yyMoreLen = (int) (yyscanner->yyCBufP - yyscanner->yytext_ptr);
				yyscanner->yyMoreFlag = false;
			}
]])
]])
			yyCp = yyscanner->yyCBufP;

			/* Support of yytext. */
			*yyCp = yyscanner->yyHoldChar;

			/* yyBp points to the position in yyChBuf of the start of
			 * the current run.
			 */
			yyBp = yyCp;

M4_GEN_START_STATE

	yyMatchLabel:
			/* Generate the code to find the next match. */
m4_ifdef([[M4_MODE_FIND_ACTION_FULLTBL]], [[m4_dnl
m4_ifdef([[M4_MODE_GENTABLES]], [[m4_dnl
			while ((yyCurrentState = yyNxt[yyCurrentState][ M4_EC(YY_SC_TO_UI(*yyCp)) ]) > 0) {
]])
m4_ifdef([[M4_MODE_NO_GENTABLES]], [[
			while ((yyCurrentState = yyNxt[yyCurrentState*YYNXT_LOLEN + M4_EC(YY_SC_TO_UI(*yyCp)) ]) > 0) {
]])
M4_GEN_BACKING_UP
				yyCp++;
			}
			yyCurrentState = -yyCurrentState;
]])
m4_ifdef([[M4_MODE_FULLSPD]], [[
			M4_GEN_NEXT_MATCH_FULLSPD(M4_EC(YY_SC_TO_UI(*yyCp)), M4_EC(YY_SC_TO_UI(*++yyCp)))
]])
m4_ifdef([[M4_MODE_NO_FULLSPD_OR_FULLTBL]], [[
			do {
				M4_GEN_NEXT_COMPRESSED_STATE(M4_EC(YY_SC_TO_UI(*yyCp)))

				m4_ifdef([[M4_MODE_USES_REJECT]], [[*yyscanner->yyStatePtr++ = yyCurrentState;]])
				++yyCp;

			}
			m4_ifdef([[M4_MODE_INTERACTIVE]], [[while (yyBase[yyCurrentState] != YY_JAMBASE);]])
			m4_ifdef([[M4_MODE_NO_INTERACTIVE]], [[while (yyCurrentState != YY_JAMSTATE);]])

m4_ifdef([[M4_MODE_NO_USES_REJECT]], [[
m4_ifdef([[M4_MODE_NO_INTERACTIVE]], [[
			/* Do the guaranteed-needed backing up to figure out
			 * the match.
			 */
			yyCp = yyscanner->yyLastAcceptingCharPos;
			yyCurrentState = yyscanner->yyLastAcceptingState;
]])
]])
]])

	yyFindActionLabel:
			/* code to find the action number goes here */
			m4_ifdef([[M4_MODE_FULLSPD]], [[yyAct = yyCurrentState[-1].yyNxt;]])
			m4_ifdef([[M4_MODE_FIND_ACTION_FULLTBL]], [[yyAct = yyAccept[yyCurrentState];]])
m4_ifdef([[M4_MODE_FIND_ACTION_REJECT]], [[
			yyCurrentState = *--yyscanner->yyStatePtr;
			yyscanner->yyLp = yyAccept[yyCurrentState];
m4_ifdef([[M4_MODE_FIND_ACTION_REJECT_REALLY_USED]], [[findRuleLabel: /* we branch to this label when backing up */]])
			for (; ;) {	/* loop until we find out what rule we matched */
				if (yyscanner->yyLp && yyscanner->yyLp < yyAccept[yyCurrentState + 1]) {
					yyAct = yyAcclist[yyscanner->yyLp];
m4_ifdef([[M4_MODE_VARIABLE_TRAILING_CONTEXT_RULES]], [[
					if ((yyAct & YY_TRAILING_HEAD_MASK) != 0 || yyscanner->yyLookingForTrailBegin) {
						if (yyAct == yyscanner->yyLookingForTrailBegin) {
							yyscanner->yyLookingForTrailBegin = 0;
							yyAct &= ~YY_TRAILING_HEAD_MASK;
							break;
						}
					} else if ((yyAct & YY_TRAILING_MASK) != 0) {
						yyscanner->yyLookingForTrailBegin = yyAct & ~YY_TRAILING_MASK;
						yyscanner->yyLookingForTrailBegin |= YY_TRAILING_HEAD_MASK;
m4_ifdef([[M4_MODE_REAL_REJECT]], [[
						/* Remember matched text in case we back up
						 * due to REJECT.
						 */
						yyscanner->yyFullMatch = yyCp;
						yyscanner->yyFullState = yyscanner->yyStatePtr;
						yyscanner->yyFullLp = yyscanner->yyLp;
]])
					} else {
						yyscanner->yyFullMatch = yyCp;
						yyscanner->yyFullState = yyscanner->yyStatePtr;
						yyscanner->yyFullLp = yyscanner->yyLp;
						break;
					}
					++yyscanner->yyLp;
				goto findRuleLabel;
]])
m4_ifdef([[M4_MODE_NO_VARIABLE_TRAILING_CONTEXT_RULES]], [[
					/* Remember matched text in case we back up due to
					 * trailing context plus REJECT.
					 */
					yyscanner->yyFullMatch = yyCp;
					break;
]])
				}

				--yyCp;

				/* We could consolidate the following two lines with those at
				 * the beginning, but at the cost of complaints that we're
				 * branching inside a loop.
				 */
				yyCurrentState = *--yyscanner->yyStatePtr;
				yyscanner->yyLp = yyAccept[yyCurrentState];
			} /* close for */
]])
m4_ifdef([[M4_MODE_FIND_ACTION_COMPRESSED]], [[		yyAct = yyAccept[yyCurrentState];
			if (yyAct == 0) { /* have to back up */
				yyCp = yyscanner->yyLastAcceptingCharPos;
				yyCurrentState = yyscanner->yyLastAcceptingState;
				yyAct = yyAccept[yyCurrentState];
			}
]])

			yyDoBeforeAction(yyscanner, yyCp, yyBp);

m4_ifdef([[M4_MODE_YYLINENO]],[[
m4_define([[M4_YYL_BASE]], [[m4_ifdef([[M4_MODE_YYMORE_USED]],
			    [[m4_ifdef([[M4_MODE_YYTEXT_IS_ARRAY]],
				       [[yyscanner->yyPrevMoreOffset]], [[yyscanner->yyMoreLen]])]], [[0]])]])
			if (yyAct != YY_END_OF_BUFFER && yyRuleCanMatchEOL[yyAct]) {
				int yyl;
				for (yyl = M4_YYL_BASE; yyl < yyscanner->yyleng; ++yyl) {
					if (yyscanner->yytext[yyl] == '\n') {
						yybumpline(yyscanner);

					}
				}
			}
]])

		doActionLabel:	/* This label is used only to access EOF actions. */

m4_ifdef([[M4_MODE_DEBUG]], [[
			if (yyscanner->yyflexdebug) {
				if (yyAct == 0) {
					fprintf(stderr, "--scanner backing up\n");
				} else if (yyAct < YY_NUM_RULES) {
					fprintf(stderr, "--accepting rule at line %ld (\"%s\")\n",
						(long)yy_rule_linenum[yyAct], yyscanner->yytext);
				} else if (yyAct == YY_NUM_RULES) {
					fprintf(stderr, "--accepting default rule (\"%s\")\n",
						 yyscanner->yytext);
     				} else if (yyAct == YY_NUM_RULES + 1) {
					fprintf(stderr, "--(end of buffer or a NUL)\n");
				} else {
					fprintf(stderr, "--EOF (start condition %d)\n", yystart(yyscanner));
				}
			}
]])

			switch (yyAct) { /* beginning of action switch */
m4_ifdef([[M4_MODE_NO_USES_REJECT]], [[
m4_ifdef([[M4_MODE_HAS_BACKING_UP]], [[
			case 0: /* must back up */
				/* undo the effects of yyDoBeforeAction() */
				*yyCp = yyscanner->yyHoldChar;

				/* Backing-up info for compressed tables is taken *after* */
				/* yyCp has been incremented for the next state. */
				yyCp = yyscanner->yyLastAcceptingCharPos;
				m4_ifdef([[M4_MODE_FULLSPD]], [[yyCp++;]])
				m4_ifdef([[M4_MODE_FIND_ACTION_FULLTBL]], [[yyCp++;]])

				yyCurrentState = yyscanner->yyLastAcceptingState;
				goto yyFindActionLabel;
]])
]])
%% [5.0] user actions get inserted here

			case YY_END_OF_BUFFER:
			{
				/* Amount of text matched not including the EOB char. */
				int yyAmountOfMatchedText = (int) (yyCp - yyscanner->yytext_ptr) - 1;

				/* Undo the effects of yyDoBeforeAction(). */
				*yyCp = yyscanner->yyHoldChar;
				YY_RESTORE_YY_MORE_OFFSET

				if (yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyBufferStatus == YY_BUFFER_NEW) {
					/* We're scanning a new file or input source.  It's
					 * possible that this happened because the user
					 * just pointed yyin at a new source and called
					 * yylex().  If so, then we have to assure
					 * consistency between yy_current_buffer(yyscanner) and our
					 * globals.  Here is the right place to do so, because
					 * this is the first action (other than possibly a
					 * back-up) that will match for the new input source.
					 */
					yyscanner->yyNChars = yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyNChars;
					yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyInputFile = yyscanner->yyin;
					yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyBufferStatus = YY_BUFFER_NORMAL;
				}

				/* Note that here we test for yyCBufP "<=" to the position
				 * of the first EOB in the buffer, since yyCBufP will
				 * already have been incremented past the NUL character
				 * (since all states make transitions on EOB to the
				 * end-of-buffer state).  Contrast this with the test
				 * in input().
				 */
				if (yyscanner->yyCBufP <= &yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf[yyscanner->yyNChars]) { /* This was really a NUL. */
					yyStateType yyNextState;

					yyscanner->yyCBufP = yyscanner->yytext_ptr + yyAmountOfMatchedText;

					yyCurrentState = yyGetPreviousState(yyscanner);

					/* Okay, we're now positioned to make the NUL
					 * transition.  We couldn't have
					 * yyGetPreviousState() go ahead and do it
					 * for us because it doesn't know how to deal
					 * with the possibility of jamming (and we don't
					 * want to build jamming into it because then it
					 * will run more slowly).
					 */

					yyNextState = yyTryNULtrans(yyCurrentState, yyscanner);

					yyBp = yyscanner->yytext_ptr + YY_MORE_ADJ;

					if (yyNextState) {
						/* Consume the NUL. */
						yyCp = ++yyscanner->yyCBufP;
						yyCurrentState = yyNextState;
						goto yyMatchLabel;
					} else {
%# Disguised case statement on table modes
						m4_ifdef([[M4_MODE_FULLSPD]], [[yyCp = yyscanner->yyCBufP;]])
						m4_ifdef([[M4_MODE_FIND_ACTION_FULLTBL]], [[yyCp = yyscanner->yyCBufP;]])
m4_ifdef([[M4_MODE_NO_FULLSPD_OR_FULLTBL]], [[
m4_ifdef([[M4_MODE_NO_USES_REJECT]], [[
m4_ifdef([[M4_NOT_MODE_INTERACTIVE]], [[
						/* Do the guaranteed-needed backing up to figure
						 * out the match.
						 */
						yyCp = yyscanner->yyLastAcceptingCharPos;
						yyCurrentState = yyscanner->yyLastAcceptingState;
]])
]])
%# Disguised case statement on table modes ends
m4_ifdef([[M4_MODE_FIND_ACTION_REJECT_OR_INTERACTIVE]], [[
						/* Still need to initialize yyCp, though
						 * yyCurrentState was set up by
						 * yyGetPreviousState().
						 */
						yyCp = yyscanner->yyCBufP;
]])
]])
						goto yyFindActionLabel;
					}
				} else {	/* not a NUL */
					switch (yy_get_next_buffer(yyscanner)) {
					case EOB_ACT_END_OF_FILE:
						yyscanner->yyDidBufferSwitchOnEof = false;

						if (yywrap(yyscanner)) {
							/* Note: because we've taken care in
							 * yy_get_next_buffer() to have set up
							 * yytext, we can now set up
							 * yyCBufP so that if some total
							 * hoser (like flex itself) wants to
							 * call the scanner after we return the
							 * flexEOF, it'll still work - another
							 * flexEOF will get returned.
							 */
							yyscanner->yyCBufP = yyscanner->yytext_ptr + YY_MORE_ADJ;

							yyAct = YY_STATE_EOF(yystart(yyscanner));
							goto doActionLabel;
						} else {
							if (! yyscanner->yyDidBufferSwitchOnEof) {
								yyrestart(yyscanner->yyin, yyscanner);
							}
						}
						break;
					case EOB_ACT_CONTINUE_SCAN:
						yyscanner->yyCBufP = yyscanner->yytext_ptr + yyAmountOfMatchedText;

						yyCurrentState = yyGetPreviousState(yyscanner);

						yyCp = yyscanner->yyCBufP;
						yyBp = yyscanner->yytext_ptr + YY_MORE_ADJ;
						goto yyMatchLabel;

					case EOB_ACT_LAST_MATCH:
						yyscanner->yyCBufP =
						&yyscanner->yyBufferStack[yyscanner->yyBufferStackTop]->yyChBuf[yyscanner->yyNChars];

						yyCurrentState = yyGetPreviousState(yyscanner);

						yyCp = yyscanner->yyCBufP;
						yyBp = yyscanner->yytext_ptr + YY_MORE_ADJ;
						goto yyFindActionLabel;
					} /* end EOB inner switch */
				} /* end if */
				break;
			} /* case YY_END_OF_BUFFER */
			default:
				yypanic("fatal flex scanner internal error--no action found", yyscanner);
			} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of yylex */

m4_undefine([[yyless]])

/* Redefine yyless() so it works in section 3 code. */

void yyless(int n, FlexLexer *yyscanner) {
	/* Undo effects of setting up yytext. */
	m4_ifdef([[M4_MODE_YYLINENO]], [[yyLessLineno(n, yyscanner);]])
	yyscanner->yytext[yyscanner->yyleng] = yyscanner->yyHoldChar;
	yyscanner->yyCBufP = yyscanner->yytext + n;
	yyscanner->yyHoldChar = *yyscanner->yyCBufP;
	*yyscanner->yyCBufP = '\0';
	yyscanner->yyleng = n;
}

static int yy_init_globals (FlexLexer *yyscanner) {
	/*
	 * This function is called from yylex_destroy(), so don't allocate here.
	 */
	yyscanner->yyBufferStack = NULL;
	yyscanner->yyBufferStackTop = 0;
	yyscanner->yyBufferStackMax = 0;
	yyscanner->yyCBufP = NULL;
	yyscanner->yyInit = false;
	yyscanner->yyStart = 0;
	yyscanner->yyStartStackOffset = 0;
	yyscanner->yyStartStackDepth = 0;
	yyscanner->yyStartStack =  NULL;

m4_ifdef([[M4_MODE_USES_REJECT]],
[[
	yyscanner->yyStateBuf = NULL;
	yyscanner->yyStatePtr = NULL;
	yyscanner->yyStateBufMax = 0;
	yyscanner->yyFullMatch = NULL;
	yyscanner->yyLp = 0;
]])

m4_ifdef([[M4_MODE_YYTEXT_IS_ARRAY]],
[[
	yyscanner->yytext_ptr = 0;
	yyscanner->yyMoreOffset = 0;
	yyscanner->yyPrevMoreOffset = 0;
]])

	yyscanner->yyin = NULL;
	yyscanner->yyout = NULL;

	return 0;
}

/* User-visible API */

/* yylex_init is special because it creates the scanner itself, so it is
 * the ONLY reentrant function that doesn't take the scanner as the last argument.
 * That's why we explicitly handle the declaration, instead of using our macros.
 */
int yylex_init(FlexLexer **globalsPtr) {
	if (globalsPtr == NULL) {
		errno = EINVAL;
		return 1;
	}

	*globalsPtr = (FlexLexer *) yyalloc (sizeof(FlexLexer), NULL);

	if (*globalsPtr == NULL) {
		errno = ENOMEM;
		return 1;
	}

	/* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
	memset(*globalsPtr,0x00,sizeof(FlexLexer));

	return yy_init_globals (*globalsPtr);
}

m4_ifdef([[M4_MODE_EXTRA_TYPE]], [[m4_dnl
/* yylex_init_extra has the same functionality as yylex_init, but follows the
 * convention of taking the scanner as the last argument. Note however, that
 * this is a *pointer* to a scanner, as it will be allocated by this call (and
 * is the reason, too, why this function also must handle its own declaration).
 * The user defined value in the first argument will be available to yyalloc in
 * the yyextra field.
 */
int yylex_init_extra(M4_MODE_EXTRA_TYPE yyUserDefined, FlexLexer **globalsPtr) {
	FlexLexer dummyYyguts;

	yyset_extra(yyUserDefined, &dummy_yyguts);

	if (globalsPtr == NULL) {
		errno = EINVAL;
		return 1;
	}

	*globalsPtr = (FlexLexer *) yyalloc(sizeof(FlexLexer), &dummyYyguts);

	if (*globalsPtr == NULL) {
		errno = ENOMEM;
		return 1;
	}

	/* By setting to 0xAA, we expose bugs in
	   yy_init_globals. Leave at 0x00 for releases. */
	memset(*globalsPtr,0x00,sizeof(FlexLexer));

	yyset_extra(yyUserDefined, *globalsPtr);

	return yy_init_globals(*globalsPtr);
}
]])

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy(FlexLexer *yyscanner) {

	/* Pop the buffer stack, destroying each element. */
	while(yy_current_buffer(yyscanner)) {
		yy_delete_buffer(yy_current_buffer(yyscanner), yyscanner);
		yyscanner->yyBufferStack[yyscanner->yyBufferStackTop] = NULL;
		yypop_buffer_state(yyscanner);
	}

	/* Destroy the stack itself. */
	yyfree(yyscanner->yyBufferStack, yyscanner);
	yyscanner->yyBufferStack = NULL;

	/* Destroy the start condition stack. */
        yyfree(yyscanner->yyStartStack, yyscanner);
        yyscanner->yyStartStack = NULL;

m4_ifdef([[M4_MODE_USES_REJECT]],
[[
	yyfree(yyscanner->yyStateBuf, yyscanner);
	yyscanner->yyStateBuf = NULL;
]])

	/* Reset the globals. This is important in a non-reentrant scanner so the next time
	 * yylex() is called, initialization will occur. */
	yy_init_globals(yyscanner);

	/* Destroy the main struct (reentrant only). */
	yyfree (yyscanner, yyscanner);
	yyscanner = NULL;
	return 0;
}

m4_ifdef([[M4_YY_MAIN]], [[
int main () {
	FlexLexer *lexer;
	yylex_init(&lexer);
	yylex(lexer);
	yylex_destroy(lexer);
	yylex();

	return 0;
}
]])

%# Local Variables:
%# mode:c
%# c-file-style:"k&r"
%# c-basic-offset:8
%# End:
