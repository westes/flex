/*
 * This file is part of flex.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the University nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE.
 */

/*
 * This test present ability to handle various encodings of incoming data
 * by that same compiled parser. Test verifies ability to properly handle
 * files in three encodings.
 *
 * This scanner file is written in ISO-8859-1 (LATIN-1), and this is also the
 * first readable charset for generated scanner. Second and third, EBCDIC-500
 * and CP850 are processed in charset_handler function provided in this .l file.
 *
 * This file generates both reentrant and no-reentrant scanners by being
 * preprocessed by m4 with or without VARIANT_REENTRANT value defined.
 */

%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "config.h"

m4_ifdef(`VARIANT_REENTRANT', `#define VARIANT_REENTRANT 1', `')
m4_ifdef(`VARIANT_CPLUSPLUS', `#define VARIANT_CPLUSPLUS 1', `')

#if VARIANT_CPLUSPLUS
#define out(str) (*yyout << str)
#else
#define out(str) (fprintf(yyout, str))
#endif

%}

%option 8bit prefix="test" charset-source="ISO-8859-1"
%option nounput nomain noinput noyywrap charset
%option warn

m4_ifdef(`VARIANT_REENTRANT', `%option reentrant', `')
m4_ifdef(`VARIANT_CPLUSPLUS', `%option c++')

%%

[A-ZÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞ]         { out("U"); }
[a-zàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿß]       { out("L"); }
[0-9]                                       { out("N"); }

%%

#if VARIANT_CPLUSPLUS
class TestFlexLexer: public yyFlexLexer {
public:
#endif
/*
 * The function provided by scanner to handle encodings. It gets set of incoming
 * bytes and convert into set of characters in internal representation - in the
 * case of 7/8bit parsers, internal representation is always the same as
 * "charset-source"
 *
 * charset - charset name (in ASCII)
 * source - incoming bytes
 * source_bytes - count of incoming bytes
 * target - where to place output characters
 * target_length - maximum number of characters (in YY_CHARs) that can be placed
 *         in "target" buffer
 * converted_bytes - pointer to variable that should be set to number of bytes
 *         that has been properly converted from "source" buffer
 *
 * RETURNS: number of characters that has been written into "target" buffer.
 *         Must not be greater than value of "target_length" parameter.
 */
#if VARIANT_CPLUSPLUS
size_t yycharset_handler(char *charset, char* source, size_t source_bytes,
        YY_CHAR* target, size_t target_length, size_t* converted_bytes)
#else
size_t charset_handler(char *charset, char* source, size_t source_bytes,
        YY_CHAR* target, size_t target_length, size_t* converted_bytes
#if VARIANT_REENTRANT
        , yyscan_t yyscanner
#endif
        )
#endif
{
    /* conversion from CP850 to ISO-8859-1. Unrepresentable values are set to -1 */
    static int conversion_table_cp850[256] = {
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,

0xC7, 0xFC, 0xE9, 0xE2, 0xE4, 0xE0, 0xE5, 0xE7, 0xEA, 0xEB, 0xE8, 0xEF, 0xEE, 0xEC, 0xC4, 0xC5,
0xC9, 0xE6, 0xC6, 0xF4, 0xF6, 0xF2, 0xFB, 0xF9, 0xFF, 0xD6, 0xDC, 0xF8, 0xA3, 0xD8, 0xD7,   -1,
0xE1, 0xED, 0xF3, 0xFA, 0xF1, 0xD1, 0xAA, 0xBA, 0xBF, 0xAE, 0xAC, 0xBD, 0xBC, 0xA1, 0xAB, 0xBB,
  -1,   -1,   -1,   -1,   -1, 0xC1, 0xC2, 0xC0, 0xA9,   -1,   -1,   -1,   -1, 0xA2, 0xA5,   -1,
  -1,   -1,   -1,   -1,   -1,   -1, 0xE3, 0xC3,   -1,   -1,   -1,   -1,   -1,   -1,   -1, 0xA4,
0xF0, 0xD0, 0xCA, 0xCB, 0xC8,   -1, 0xCD, 0xCE, 0xCF,   -1,   -1,   -1,   -1, 0xA6, 0xCC,   -1,
0xD3, 0xDF, 0xD4, 0xD2, 0xF5, 0xD5, 0xB5, 0xFE, 0xDE, 0xDA, 0xDB, 0xD9, 0xFD, 0xDD, 0xAF, 0xB4,
0xAD, 0xB1,   -1, 0xBE, 0xB6, 0xA7, 0xF7, 0xB8, 0xB0, 0xA8, 0xB7, 0xB9, 0xB3, 0xB2,   -1, 0xA0
    };

    /* conversion from EBCDIC-500 to ISO-8859-1. Unrepresentable values are set to -1 */
    static int conversion_table_ebcdic500[256] = {
0x00, 0x01, 0x02, 0x03,   -1, 0x09,   -1, 0x7F,   -1,   -1,   -1, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
0x10, 0x11, 0x12, 0x13,   -1, 0x85, 0x08,   -1, 0x18, 0x19,   -1,   -1, 0x1C, 0x1D, 0x1E, 0x1F,
  -1,   -1,   -1,   -1,   -1, 0x0A, 0x17, 0x1B,   -1,   -1,   -1,   -1,   -1, 0x05, 0x06, 0x07,
  -1,   -1, 0x16,   -1,   -1,   -1,   -1, 0x04,   -1,   -1,   -1,   -1, 0x14, 0x15,   -1, 0x1A,
0x20, 0xA0, 0xE2, 0xE4, 0xE0, 0xE1, 0xE3, 0xE5, 0xE7, 0xF1, 0x5B, 0x2E, 0x3C, 0x28, 0x2B, 0x21,
0x26, 0xE9, 0xEA, 0xEB, 0xE8, 0xED, 0xEE, 0xEF, 0xEC, 0xDF, 0x5D, 0x24, 0x2A, 0x29, 0x3B, 0x5E,
0x2D, 0x2F, 0xC2, 0xC4, 0xC0, 0xC1, 0xC3, 0xC5, 0xC7, 0xD1, 0xA6, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
0xF8, 0xC9, 0xCA, 0xCB, 0xC8, 0xCD, 0xCE, 0xCF, 0xCC, 0x60, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,

0xD8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xAB, 0xBB, 0xF0, 0xFD, 0xFE, 0xB1,
0xB0, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0xAA, 0xBA, 0xE6, 0xB8, 0xC6, 0xA4,
0xB5, 0x7E, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0xBF, 0xD0, 0xDD, 0xDE, 0xAE,
0xA2, 0xA3, 0xA5, 0xB7, 0xA9, 0xA7, 0xB6, 0xBC, 0xBD, 0xBE, 0xAC, 0x7C, 0xAF, 0xA8, 0xB4, 0xD7,
0x7B, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xAD, 0xF4, 0xF6, 0xF2, 0xF3, 0xF5,
0x7D, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0xB9, 0xFB, 0xFC, 0xF9, 0xFA, 0xFF,
0x5C, 0xF7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0xB2, 0xD4, 0xD6, 0xD2, 0xD3, 0xD5,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0xB3, 0xDB, 0xDC, 0xD9, 0xDA,   -1
    };

    static int *cnv = NULL;
    if(strcmp(charset, "CP850") == 0)
        cnv = conversion_table_cp850;
    else if(strcmp(charset, "EBCDIC-500") == 0)
        cnv = conversion_table_ebcdic500;
    else
        YY_FATAL_ERROR("Unknown encoding");

    if(target_length < source_bytes)
            YY_FATAL_ERROR("Too small buffer");
    int i;
    for(i = 0; i < source_bytes; ++i) {
        char in = source[i];
        int ch = cnv[(unsigned char)in];
        if(ch == -1) {
            char msg[256];
            snprintf(msg, sizeof(msg), "Unsupported byte 0x%x",
                (unsigned int)(unsigned char)in);
            YY_FATAL_ERROR(msg);
        }
        target[i] = ch;
    }
    *converted_bytes = source_bytes;
    return source_bytes;
}

#if VARIANT_CPLUSPLUS
};
#endif

int main (int argc, char *argv[])
{
    if(argc < 2) {
        fprintf(stderr, "USAGE: %s [CHARSET]", argv[0]);
        return 1;
    }
    char *charset = argv[1];

#if VARIANT_CPLUSPLUS
    TestFlexLexer lexer;
    lexer.set_charset(charset);
    assert(strcmp(lexer.get_charset(), charset)==0);
    lexer.yylex();
#elif VARIANT_REENTRANT
    yyscan_t lexer;

    yylex_init(&lexer);

    yyset_in(stdin, lexer);
    yyset_out(stdout, lexer);

    yyset_charset(charset, lexer);
    assert(strcmp(yyget_charset(lexer), charset)==0);

    yyset_charset_handler(charset_handler, lexer);
    assert(yyget_charset_handler(lexer) == charset_handler);

    yylex( lexer );

    yylex_destroy( lexer);
#else
    yyin = stdin;
    yyout = stdout;
    yycharset = charset;
    yycharset_handler = charset_handler;

    yylex();
#endif
    return 0;
}
